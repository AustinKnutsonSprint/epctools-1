<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EpcTools: Enhanced Packet Core Application Development Tools for Linux</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="my_customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EpcTools
   </div>
   <div id="projectbrief">An event based multi-threaded C++ development framework.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Enhanced Packet Core Application Development Tools for Linux </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><em><b><a class="el" href="classEpcTools.html" title="The primary class used to initialize/uninitialize EpcTools.">EpcTools</a></b></em> is a set of C++ classes that simplifies the development and management of EPC applications. This library is intended for use on any Linux based system that supports g++ and pthreads.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Contents</h1>
<div class="mycustomlist"> <ol>
<li>
<a href="#dependencies">Dependencies</a> </li>
<li>
<a href="#installation">Installation</a> </li>
<li>
<a href="#feature-overview">Feature Overview</a> <ol>
<li>
<a href="#configuration">Configuration</a> <ol>
<li>
<a href="#configuration-file">Configuration File</a> </li>
<li>
<a href="#configuration-command-line">Command Line</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview-public-private">Public vs. Private</a> </li>
<li>
<a href="#feature-overview-shared-memory">Shared Memory</a> </li>
<li>
<a href="#feature-overview-threads">Threads</a> <ol>
<li>
<a href="#feature-overview-threads-basic-thread">Basic Thread</a> </li>
<li>
<a href="#feature-overview-threads-event-thread">Event Thread</a> <ol>
<li>
<a href="#feature-overview-threads-event-thread-queue">Event Queues</a> </li>
<li>
<a href="#feature-overview-threads-event-thread-message">Event Message</a> </li>
<li>
<a href="#feature-overview-threads-event-thread-message-custom">Custom Event Message</a> </li>
<li>
<a href="#feature-overview-threads-event-thread-event-send">Sending an Event</a> </li>
<li>
<a href="#feature-overview-threads-event-thread-event-processing">Event Processing</a> </li>
<li>
<a href="#feature-overview-threads-event-thread-timers">Timers</a> </li>
<li>
<a href="#feature-overview-threads-event-thread-example">Example</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview-threads-public-event-threads">Public Event Threads</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview-message-queue">Message Queue</a> <ol>
<li>
<a href="#feature-overview-message-queue-pack-unpack">Pack/Unpack</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview-synchronization">Synchronization</a> <ol>
<li>
<a href="#feature-overview-synchronization-mutex">Mutex</a> </li>
<li>
<a href="#feature-overview-synchronization-semaphore">Semaphore</a> </li>
<li>
<a href="#feature-overview-synchronization-event">Event</a> </li>
<li>
<a href="#feature-overview-synchronization-read-write-lock">Read/Write Lock</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview-socket-communications">Socket Communications</a> <ol>
<li>
<a href="#feature-overview-socket-communications-socket-thread">Socket Thread</a> </li>
<li>
<a href="#feature-overview-socket-communications-tcp">TCP</a> </li>
<li>
<a href="#feature-overview-socket-communications-udp">UDP</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview-logging">Logging</a> <ol>
<li>
<a href="#feature-overview-logging-configuration">Configuration</a> <ol>
<li>
<a href="#feature-overview-logging-configuration-json">JSON</a> </li>
<li>
<a href="#feature-overview-logging-configuration-code">Code</a> </li>
<li>
<a href="#feature-overview-logging-configuration-sinksets">Sink Sets</a> </li>
<li>
<a href="#feature-overview-logging-configuration-logs">Logs</a> </li>
<li>
<a href="#feature-overview-logging-configuration-loglevels">Log Levels</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview-logging-logmessages">Log Messages</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview-dns">DNS</a> <ol>
<li>
<a href="#feature-overview-dns-cache">Cache</a> </li>
<li>
<a href="#feature-overview-dns-queries">Queries</a> </li>
<li>
<a href="#feature-overview-dns-epc-node-discovery">EPC Node Discovery</a> </li>
<li>
<a href="#feature-overview-dns-node-colocation">Node Colocation</a> </li>
<li>
<a href="#feature-overview-dns-diameter-s-naptr">Diameter S-NAPTR</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview-management-interface-rest">Management Interface (REST)</a> </li>
<li>
<a href="#feature-overview-freediameter">freeDiameter</a> </li>
<li>
<a href="#feature-overview-statistics">Interface Statistics</a> </li>
<li>
<a href="#feature-overview-timer-pool">Timer Pool</a> </li>
<li>
<a href="#feature-overview-miscellaneous-classes">Miscellaneous Classes</a>  </li>
</ol>
</li>
</ol>
</div><p><a class="anchor" id="dependencies"></a> </p>
<h1><a class="anchor" id="autotoc_md11"></a>
Dependencies</h1>
<ul>
<li><a href="https://github.com/omec-project/freediameter">freeDiameter</a> - an implementation of the Diameter protocol</li>
<li><a href="http://rapidjson.org">RapidJSON</a> - a JSON parser and generator for C++</li>
<li><a href="https://github.com/gabime/spdlog">spdlog</a> - very fast, header-only/compiled, C++ logging library</li>
<li><a href="http://pistache.io/">pistache</a> - an elegant C++ REST framework</li>
<li><a href="https://www.sourceware.org/bzip2/">bzip2</a> - a freely available, patent free (see below), high-quality data compressor</li>
</ul>
<p><a class="anchor" id="installation"></a> </p>
<h1><a class="anchor" id="autotoc_md12"></a>
Installation</h1>
<p><em><b>Update your system.</b></em> </p><div class="fragment"><div class="line">$ sudo apt-get update</div>
</div><!-- fragment --><p> <em><b>Install Ubuntu 16.04 prerequisites.</b></em> </p><div class="fragment"><div class="line">sudo apt-get install mercurial cmake make gcc g++ bison flex libsctp-dev libgnutls-dev libgcrypt-dev libidn11-dev m4 automake libtool</div>
</div><!-- fragment --><p> <em><b>Install Ubuntu 18.04 prerequisites.</b></em> </p><div class="fragment"><div class="line">sudo apt-get install mercurial cmake make gcc g++ bison flex libsctp-dev libgnutls28-dev libgcrypt-dev libidn11-dev m4 automake libtool</div>
</div><!-- fragment --><p> <em><b>Clone the project, install the dependencies (via configure), build the static library and install.</b></em> </p><div class="fragment"><div class="line">$ git clone https://github.com/brianwaters3/epctools.git epctools</div>
<div class="line">$ cd epctools</div>
<div class="line">$ ./configure</div>
<div class="line">$ make</div>
<div class="line">$ sudo make install</div>
</div><!-- fragment --><p><em><b>To compile with optimization disabled run the following</b></em> </p><div class="fragment"><div class="line">$ cd epctools</div>
<div class="line">$ env CXXFLAGS=&quot;$CXXFLAGS -O0 -g&quot; ./configure</div>
<div class="line">$ make clean</div>
<div class="line">$ make</div>
<div class="line">$ sudo make install</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview"></a> </p>
<h1><a class="anchor" id="autotoc_md13"></a>
Feature Overview</h1>
<p><a class="anchor" id="configuration"></a> </p>
<h2><a class="anchor" id="autotoc_md14"></a>
Configuration</h2>
<p><em><b><a class="el" href="classEpcTools.html" title="The primary class used to initialize/uninitialize EpcTools.">EpcTools</a></b></em> is configured via a JSON configuration file. Additionally, application specific configuration items may be defined in the same JSON configuration file and also on the command line. The options contained in JSON configuration file(s) and command line arguments can be accessed via an instance of <a class="el" href="classEGetOpt.html">EGetOpt</a>.</p>
<p><a class="anchor" id="configuration-file"></a> </p>
<h3><a class="anchor" id="autotoc_md15"></a>
Configuration File</h3>
<p>Multiple JSON configuration files can be loaded by <a class="el" href="classEGetOpt.html">EGetOpt</a>. <br  />
 <b>Sample JSON Configuration File</b> </p><div class="fragment"><div class="line">{</div>
<div class="line">    &quot;EpcApplication&quot;: {</div>
<div class="line">        &quot;freeDiameter&quot;: {</div>
<div class="line">            &quot;configfile&quot;: &quot;conf/epc_app_client.conf&quot;,</div>
<div class="line">            &quot;originhost&quot;: &quot;epcapp_client.localdomain&quot;,</div>
<div class="line">            &quot;originrealm&quot;: &quot;localdomain&quot;,</div>
<div class="line">            &quot;peerhost&quot;: &quot;epcappserver.localdomain&quot;,</div>
<div class="line">            &quot;peerport&quot;: 30868,</div>
<div class="line">            &quot;peerip&quot;: &quot;10.0.2.15&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;role&quot;: &quot;client&quot;,</div>
<div class="line">        &quot;cliport&quot;: 9080</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>These JSON configuration parameters can be loaded and access by <a class="el" href="classEGetOpt.html">EGetOpt</a> as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>  *argv[])</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classEGetOpt.html">EGetOpt</a> opt;</div>
<div class="line">    <a class="code" href="classEString.html">EString</a> optfile;</div>
<div class="line">      </div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// load a configuration file</span></div>
<div class="line">        opt.<a class="code" href="classEGetOpt.html#a2cdd38746dcacdf53d016a50289e24a6">loadFile</a>(<span class="stringliteral">&quot;conf/epc_app_server.json&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// the second argument is the value that will be returned if the parameter is not found</span></div>
<div class="line">        std::cout &lt;&lt; opt.<a class="code" href="classEGetOpt.html#a6158a901a426b724a2990a7f70d89c82">get</a>(<span class="stringliteral">&quot;/EpcApplication/freeDiameter/configfile&quot;</span>, <span class="stringliteral">&quot;not_found&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; opt.<a class="code" href="classEGetOpt.html#a6158a901a426b724a2990a7f70d89c82">get</a>(<span class="stringliteral">&quot;/EpcApplication/freeDiameter/originhost&quot;</span>, <span class="stringliteral">&quot;not_found&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; opt.<a class="code" href="classEGetOpt.html#a6158a901a426b724a2990a7f70d89c82">get</a>(<span class="stringliteral">&quot;/EpcApplication/freeDiameter/originrealm&quot;</span>, <span class="stringliteral">&quot;not_found&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; opt.<a class="code" href="classEGetOpt.html#a6158a901a426b724a2990a7f70d89c82">get</a>(<span class="stringliteral">&quot;/EpcApplication/freeDiameter/peerhost&quot;</span>, <span class="stringliteral">&quot;not_found&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; opt.<a class="code" href="classEGetOpt.html#a6158a901a426b724a2990a7f70d89c82">get</a>(<span class="stringliteral">&quot;/EpcApplication/freeDiameter/peerport&quot;</span>, 1234) &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; opt.<a class="code" href="classEGetOpt.html#a6158a901a426b724a2990a7f70d89c82">get</a>(<span class="stringliteral">&quot;/EpcApplication/freeDiameter/peerip&quot;</span>, <span class="stringliteral">&quot;not_found&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; opt.<a class="code" href="classEGetOpt.html#a6158a901a426b724a2990a7f70d89c82">get</a>(<span class="stringliteral">&quot;/EpcApplication/role&quot;</span>, <span class="stringliteral">&quot;not_found&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; opt.<a class="code" href="classEGetOpt.html#a6158a901a426b724a2990a7f70d89c82">get</a>(<span class="stringliteral">&quot;/EpcApplication/cliport/&quot;</span>, 4321) &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(<span class="keyword">const</span> std::exception&amp; e)</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; e.what() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">        <span class="keywordflow">return</span>  1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="configuration-command-line"></a> </p>
<h3><a class="anchor" id="autotoc_md16"></a>
Command Line</h3>
<p>Command line options can be accessed by defining and loading the options using <a class="el" href="classEGetOpt.html">EGetOpt</a>. The two different types of command line arguments are named and positional.</p>
<p>Named arguments have a short and/or long name, a data type and may have an optional or required parameter. An example of a short and long name of an argument are "-f" and "--file". Named arguments can be present in any order in the command line (they can even be intermixed with positional arguments).</p>
<p>A positional argument is a string argument that is referenced by a zero based index.</p>
<p>Here is an example command line and the associated JSON representation of those arguments stored by <a class="el" href="classEGetOpt.html">EGetOpt</a>:</p>
<div class="fragment"><div class="line">$ ./bin/epc_app -f conf/epc_app_server.json --print arg1 arg2 3 4 arg5</div>
</div><!-- fragment --><div class="fragment"><div class="line">{</div>
<div class="line">    &quot;cmdline&quot;: {</div>
<div class="line">        &quot;program&quot;: &quot;./bin/epc_app&quot;,</div>
<div class="line">        &quot;raw&quot;: [</div>
<div class="line">            &quot;./bin/epc_app&quot;,</div>
<div class="line">            &quot;-f&quot;,</div>
<div class="line">            &quot;conf/epc_app_server.json&quot;,</div>
<div class="line">            &quot;--print&quot;,</div>
<div class="line">            &quot;arg1&quot;,</div>
<div class="line">            &quot;arg2&quot;,</div>
<div class="line">            &quot;3&quot;,</div>
<div class="line">            &quot;4&quot;,</div>
<div class="line">            &quot;arg5&quot;</div>
<div class="line">        ],</div>
<div class="line">        &quot;args&quot;: [</div>
<div class="line">            &quot;arg1&quot;,</div>
<div class="line">            &quot;arg2&quot;,</div>
<div class="line">            &quot;3&quot;,</div>
<div class="line">            &quot;4&quot;,</div>
<div class="line">            &quot;arg5&quot;</div>
<div class="line">        ],</div>
<div class="line">        &quot;-f&quot;: &quot;conf/epc_app_server.json&quot;,</div>
<div class="line">        &quot;--print&quot;: true</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Here is a corresponding code example parsing and accessing command line arguments: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>  *argv[])</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structEGetOpt_1_1Option.html">EGetOpt::Option</a> options[] = {</div>
<div class="line">        {<span class="stringliteral">&quot;-h&quot;</span>, <span class="stringliteral">&quot;--help&quot;</span>, <a class="code" href="classEGetOpt.html#ad9e954c679c0c23a70dc67539876f9eea915d3f72218d564fb3c51a2d02784e6d">EGetOpt::no_argument</a>, <a class="code" href="classEGetOpt.html#ae8a83370799c1a12d423360b34486aa5a0b3b4dd30b6b0868a0a0bf720c60136f">EGetOpt::dtNone</a>},</div>
<div class="line">        {<span class="stringliteral">&quot;-f&quot;</span>, <span class="stringliteral">&quot;--file&quot;</span>, <a class="code" href="classEGetOpt.html#ad9e954c679c0c23a70dc67539876f9eea4e484f4b46faf0e8d2712a14087bb494">EGetOpt::required_argument</a>, <a class="code" href="classEGetOpt.html#ae8a83370799c1a12d423360b34486aa5a4c5bbfa8ae59b10e28b648eaf3039265">EGetOpt::dtString</a>},</div>
<div class="line">        {<span class="stringliteral">&quot;-p&quot;</span>, <span class="stringliteral">&quot;--print&quot;</span>, <a class="code" href="classEGetOpt.html#ad9e954c679c0c23a70dc67539876f9eea915d3f72218d564fb3c51a2d02784e6d">EGetOpt::no_argument</a>, <a class="code" href="classEGetOpt.html#ae8a83370799c1a12d423360b34486aa5aaef316de10f5737160a30a8a02f8211c">EGetOpt::dtBool</a>},</div>
<div class="line">        {<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <a class="code" href="classEGetOpt.html#ad9e954c679c0c23a70dc67539876f9eea915d3f72218d564fb3c51a2d02784e6d">EGetOpt::no_argument</a>, <a class="code" href="classEGetOpt.html#ae8a83370799c1a12d423360b34486aa5a0b3b4dd30b6b0868a0a0bf720c60136f">EGetOpt::dtNone</a>},</div>
<div class="line">    };</div>
<div class="line">      </div>
<div class="line">    <a class="code" href="classEGetOpt.html">EGetOpt</a> opt;</div>
<div class="line">    <a class="code" href="classEString.html">EString</a> optfile;</div>
<div class="line">      </div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        opt.<a class="code" href="classEGetOpt.html#acf035f3e4bddbb4f4ef63c05e525af2f">loadCmdLine</a>(argc, argv, options);</div>
<div class="line">        <span class="keywordflow">if</span> (opt.<a class="code" href="classEGetOpt.html#ae38885648ab68337f86a54a29384f87a">getCmdLine</a>(<span class="stringliteral">&quot;-h,--help&quot;</span>,<span class="keyword">false</span>))</div>
<div class="line">        {</div>
<div class="line">            usage();</div>
<div class="line">            <span class="keywordflow">return</span>  0;</div>
<div class="line">        }</div>
<div class="line">          </div>
<div class="line">        optfile.<a class="code" href="classEString.html#a320dce9f0bdcbf80118db0d623e176e1">format</a>(<span class="stringliteral">&quot;%s.json&quot;</span>, argv[0]);</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="classEUtility.html#a3f7d8c79a89f3694018a5f6f9bb7ced0">EUtility::file_exists</a>(optfile))</div>
<div class="line">            opt.<a class="code" href="classEGetOpt.html#a2cdd38746dcacdf53d016a50289e24a6">loadFile</a>(optfile);</div>
<div class="line">        optfile = opt.<a class="code" href="classEGetOpt.html#ae38885648ab68337f86a54a29384f87a">getCmdLine</a>( <span class="stringliteral">&quot;-f,--file&quot;</span>, <span class="stringliteral">&quot;__unknown__&quot;</span> );</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="classEUtility.html#a3f7d8c79a89f3694018a5f6f9bb7ced0">EUtility::file_exists</a>(optfile))</div>
<div class="line">            opt.<a class="code" href="classEGetOpt.html#a2cdd38746dcacdf53d016a50289e24a6">loadFile</a>(optfile);</div>
<div class="line">        <span class="keywordflow">if</span> (opt.<a class="code" href="classEGetOpt.html#ae38885648ab68337f86a54a29384f87a">getCmdLine</a>( <span class="stringliteral">&quot;-p,--print&quot;</span>, <span class="keyword">false</span>))</div>
<div class="line">            opt.<a class="code" href="classEGetOpt.html#a1545ad2f720b632d5768e77bb287cc0d">print</a>();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(<span class="keyword">const</span> std::exception&amp; e)</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; e.what() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">        <span class="keywordflow">return</span>  1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>See <a class="el" href="classEGetOpt.html">EGetOpt</a> for more information.</p>
<p><a class="anchor" id="feature-overview-public-private"></a> </p>
<h2><a class="anchor" id="autotoc_md17"></a>
Public vs. Private</h2>
<p>For some classes, <em><b><a class="el" href="classEpcTools.html" title="The primary class used to initialize/uninitialize EpcTools.">EpcTools</a></b></em> supports the concept of public classes and private. A public class/object is one that can be accessed from a different process, while a private class/object can only be accessed from within the current process. This is achieved by storing the data associated with the public object in shared memory, thereby giving access to the public objects to any process.</p>
<p><em><b>NOTE:</b></em> Since public objects have data stored in shared memory, each application that wants to have access to the public object must enable the EpcTools/EnablePublicObjects configuration option to TRUE. By default, the EpcTools/EnablePublicObjects configuration option is <code>FALSE</code>. Additionally, if an application does not call <a class="el" href="classEpcTools.html#a3c6f9a52b98c9452d2ec05c8b923087f">EpcTools::UnInitialize()</a> prior to exiting, the objects in shared memory will be remain until the shared memory is released. <em><b>This condition can lead to unexpected/unexplained application behavior.</b></em></p>
<p>The classes that support public/private are: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Public  </th><th class="markdownTableHeadLeft">Private  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="classEMutexPublic.html">EMutexPublic</a>  </td><td class="markdownTableBodyLeft"><a class="el" href="classEMutexPrivate.html">EMutexPrivate</a>  </td><td class="markdownTableBodyLeft">A mutex (mutual exclusion object) is a program object that is created so that multiple threads can take turns sharing the same resource, such as a file or list. An application can attach to a public mutex specifying the mutex ID when calling the <a class="el" href="classEMutexPublic.html#ab7ba904a8f25286d03118efaee635e84">attach()</a> method.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="classESemaphorePublic.html">ESemaphorePublic</a>  </td><td class="markdownTableBodyLeft"><a class="el" href="classESemaphorePrivate.html">ESemaphorePrivate</a>  </td><td class="markdownTableBodyLeft">A semaphore is simply a variable which is non-negative and shared between threads. The <em><b><a class="el" href="classEpcTools.html" title="The primary class used to initialize/uninitialize EpcTools.">EpcTools</a></b></em> semaphore is what is considered a counting semaphore. Semaphores are used internally in <em><b><a class="el" href="classEpcTools.html" title="The primary class used to initialize/uninitialize EpcTools.">EpcTools</a></b></em> as part of various queue implementations to represent the number of messages in the queue. If you attempt to read a queue that is empty, the semaphore will block until a message has been added to the queue. An application can attach to a public semaphore by specifying the semaphore ID when calling the <a class="el" href="classESemaphorePublic.html#a0cbb272ad36c64680929076e32440940">attach()</a> method.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="classEQueuePublic.html">EQueuePublic</a>  </td><td class="markdownTableBodyLeft"><a class="el" href="classEQueuePrivate.html">EQueuePrivate</a>  </td><td class="markdownTableBodyLeft">A message queue is a FIFO (first in first out) list of messages. Since these messages may be shared across processes, pointer values are not allowed. A message class derived from <a class="el" href="classEMessage.html">EMessage</a> provides utilities to pack and unpack data that can be written to and read from a queue. An application can attach to a public queue by specifying the queue ID when calling the <a class="el" href="classEQueuePublic.html#a66e656a4c8a66cf2c2dd053b50b4208f">init()</a> method.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="etevent_8h.html#a8954bda7259449b5e33a0c90f00f3e4a">EThreadPublic</a>  </td><td class="markdownTableBodyLeft"><a class="el" href="etevent_8h.html#a8ec0f12a7073f7d1375468685b80b8dd">EThreadPrivate</a>  </td><td class="markdownTableBodyLeft">A thread provides multiple threads of execution within the same program in a shared memory address space. Threads allow for concurrent programming and, on multiple processor/core systems, true parallelism. To send an event message to a public thread from a different process, the application must first create an instance of <a class="el" href="etevent_8h.html#a8954bda7259449b5e33a0c90f00f3e4a">EThreadPublic</a> that refers to the same application ID and thread ID that the target thread was initialized with.   </td></tr>
</table>
<p><a class="anchor" id="feature-overview-shared-memory"></a> </p>
<h2><a class="anchor" id="autotoc_md18"></a>
Shared Memory</h2>
<p>Inter process communication through shared memory is a concept where two or more processes can access the common memory and changes to the shared memory made by one process can viewed (and changed) by another process. The <a class="el" href="classESharedMemory.html">ESharedMemory</a> class provides functionality to allocate, access and release a shared memory block. Once created, a pointer to the shared memory can be retrieved using the <a class="el" href="classESharedMemory.html#affda2d92d4ba4506b196d7c266b777ad">getDataPtr()</a> method. Concurrent access to the shared memory should be controlled via an instance of <a class="el" href="classEMutexPublic.html">EMutexPublic</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="classESharedMemory.html">ESharedMemory</a> sm;</div>
<div class="line">sm.<a class="code" href="classESharedMemory.html#ad231d66f0e4d22240690008d6131cff7">init</a>( <span class="stringliteral">&quot;/tmp/sm1&quot;</span>, 1, 1048576 );</div>
<div class="line"><span class="keywordtype">void</span> *p = sm.<a class="code" href="classESharedMemory.html#affda2d92d4ba4506b196d7c266b777ad">getDataPtr</a>();</div>
</div><!-- fragment --><p>This example either creates or attaches to the shared memory identified by the file <code>"/tmp/sm1"</code> and a shared memory ID of 1 and is 1MB in size. The variable <code>p</code> is assigned the first address of the 1MB shared memory block. When <code>sm</code> goes out of scope, the shared memory will be released if no other clients are attached.</p>
<p><a class="anchor" id="feature-overview-threads"></a> </p>
<h2><a class="anchor" id="autotoc_md19"></a>
Threads</h2>
<p><a class="anchor" id="feature-overview-threads-basic-thread"></a> </p>
<h3><a class="anchor" id="autotoc_md20"></a>
Basic Thread</h3>
<p>A basic thread is a thread wrapper that will execute a user provided procedure/function in a separate thread. The basic thread is defined by deriving a class from <a class="el" href="classEThreadBasic.html">EThreadBasic</a> and overloading the <code>threadProc()</code> method. To initialize and start the thread simply call the <code>init(pVoid arg, Dword stackSize = 0)</code> method. Call <a class="el" href="classEThreadBasic.html#a8c5765e549d250fcc912b41932dc7ff5">join()</a> to wait for the thread to exit. Other useful <a class="el" href="classEThreadBasic.html">EThreadBasic</a> methods include <a class="el" href="classEThreadBasic.html#a94c06aeb1d4a549f367fda6d39c43a71">sleep(Int milliseconds)</a> and <a class="el" href="classEThreadBasic.html#a36312dfda1c19fc7f40bd82c3f9e4550">yield()</a>.</p>
<p>In this example, a basic thread is defined in the class <code>EThreadBasicTest</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">class  </span>EThreadBasicTest : <span class="keyword">public</span>  <a class="code" href="classEThreadBasic.html">EThreadBasic</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    EThreadBasicTest() : m_timetoquit(false) {}</div>
<div class="line">      </div>
<div class="line">    Dword  <a class="code" href="classEThreadBasic.html#a2af11d0367222ca518151c21f543a6ec">threadProc</a>(Void  *arg)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">while</span> (!m_timetoquit)</div>
<div class="line">        {</div>
<div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;Inside the thread [&quot;</span> &lt;&lt; (cpStr)arg &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; endl;</div>
<div class="line">            <a class="code" href="classEThreadBasic.html#a94c06aeb1d4a549f367fda6d39c43a71">sleep</a>(1000);</div>
<div class="line">        }</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Exiting EThreadTest::threadProc()&quot;</span> &lt;&lt; endl;</div>
<div class="line">        <span class="keywordflow">return</span>  0;</div>
<div class="line">    }</div>
<div class="line">      </div>
<div class="line">    Void  setTimeToQuit()</div>
<div class="line">    {</div>
<div class="line">        m_timetoquit = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">  </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> m_timetoquit;</div>
<div class="line">};</div>
<div class="line">  </div>
<div class="line">Void  EThreadBasic_test()</div>
<div class="line">{</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;EThread_test() Start&quot;</span> &lt;&lt; endl;</div>
<div class="line">      </div>
<div class="line">    EThreadBasicTest t;</div>
<div class="line">      </div>
<div class="line">    t.init((Void *)<span class="stringliteral">&quot;this is the thread argument&quot;</span>);</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;before 5 second sleep sleep&quot;</span> &lt;&lt; endl;</div>
<div class="line">    t.sleep(5000);</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;before setTimeToQuit()&quot;</span> &lt;&lt; endl;</div>
<div class="line">    t.setTimeToQuit();</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;before join&quot;</span> &lt;&lt; endl;</div>
<div class="line">    t.join();</div>
<div class="line">      </div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;EThread_test() Complete&quot;</span> &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-threads-event-thread"></a> </p>
<h3><a class="anchor" id="autotoc_md21"></a>
Event Thread</h3>
<p>An event thread responds to event messages sent to the thread by invoking the associated message handler method defined in the class. The event message queue for the thread can either be allocated from the heap, a private event thread, or allocated from shared memory, a public event thread. <a class="el" href="classEThreadEvent.html">EThreadEvent</a> is a templated class that takes two parameters 1) the queue class and 2) the event message class to be used for this thread.</p>
<p><a class="anchor" id="feature-overview-threads-event-thread-queue"></a> </p>
<h4><a class="anchor" id="autotoc_md22"></a>
Event Queues</h4>
<p>The two event queue template classes, <a class="el" href="classEThreadQueuePublic.html">EThreadQueuePublic</a> and <a class="el" href="classEThreadQueuePrivate.html">EThreadQueuePrivate</a>, each take a template parameter of an event message class. <a class="el" href="classEThreadQueuePublic.html">EThreadQueuePublic</a> creates the event queue in shared memory allowing thread events to be posted from any process, and <a class="el" href="classEThreadQueuePrivate.html">EThreadQueuePrivate</a> creates the event queue on the heap which limits thread events to only be posted from within the same process.</p>
<p><a class="anchor" id="feature-overview-threads-event-thread-message"></a> </p>
<h4><a class="anchor" id="autotoc_md23"></a>
Event Message</h4>
<p>The event message object will be passed to the event handler method defined in the derived thread class. The basic functionality of an event message is encapsulated in the <a class="el" href="classEThreadEventMessageBase.html">EThreadEventMessageBase</a> and contains the event message ID and a timer that measures the amount of time an event message spends in the event queue. Additionally, the event message must contain a void pointer. This is needed to distribute timer events.</p>
<p>The standard implementation of an event message is contained in <a class="el" href="classEThreadMessage.html">EThreadMessage</a>. The event data for this class is a union defined as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">union </span>{</div>
<div class="line">    pVoid voidptr;</div>
<div class="line">    LongLong int64;</div>
<div class="line">    Long int32[<span class="keyword">sizeof</span>(pVoid) / <span class="keyword">sizeof</span>(Long)];</div>
<div class="line">    Short int16[<span class="keyword">sizeof</span>(pVoid) / <span class="keyword">sizeof</span>(Short)];</div>
<div class="line">    Char int8[<span class="keyword">sizeof</span>(pVoid) / <span class="keyword">sizeof</span>(Char)];</div>
<div class="line">    ULongLong uint64;</div>
<div class="line">    ULong uint32[<span class="keyword">sizeof</span>(pVoid) / <span class="keyword">sizeof</span>(ULong)];</div>
<div class="line">    UShort uint16[<span class="keyword">sizeof</span>(pVoid) / <span class="keyword">sizeof</span>(UShort)];</div>
<div class="line">    UChar uint8[<span class="keyword">sizeof</span>(pVoid) / <span class="keyword">sizeof</span>(UChar)];</div>
<div class="line">} DataUnion;</div>
</div><!-- fragment --><p><a class="el" href="classEThreadMessage.html">EThreadMessage</a> has several overloaded constructors that can populate various elements of the union. Additionally, one constructor takes a reference to an instance of <a class="el" href="classEThreadEventMessageData.html">EThreadEventMessageData</a> which provides the developer with the ability to initialize any combination of union members.</p>
<p><a class="anchor" id="feature-overview-threads-event-thread-message-custom"></a> </p>
<h4><a class="anchor" id="autotoc_md24"></a>
Custom Event Message</h4>
<p>A custom or user-defined event message class can be used for a thread by developing the following classes:</p>
<ol type="1">
<li>Define the data that will be contained in the custom event message by deriving a class from <a class="el" href="classEThreadEventMessageDataBase.html">EThreadEventMessageDataBase</a>. <div class="fragment"><div class="line"><span class="keyword">class  </span>MyCustomEventData : <span class="keyword">public</span>  <a class="code" href="classEThreadEventMessageDataBase.html">EThreadEventMessageDataBase</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyCustomEventData() : <a class="code" href="classEThreadEventMessageDataBase.html">EThreadEventMessageDataBase</a>(), m_voidptr(), m_print(<a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>), m_val() {}</div>
<div class="line">    MyCustomEventData(UInt  msgid) : <a class="code" href="classEThreadEventMessageDataBase.html">EThreadEventMessageDataBase</a>(msgid), m_voidptr(), m_val() {}</div>
<div class="line">      </div>
<div class="line">    pVoid  <a class="code" href="classEThreadEventMessageDataBase.html#a54bf958a39d811cd2d2dac47eb842d22">getVoidPtr</a>() { <span class="keywordflow">return</span> m_voidptr; }</div>
<div class="line">    Void  <a class="code" href="classEThreadEventMessageDataBase.html#aab7b01e9913284bd9af3d8d510ef892d">setVoidPtr</a>(pVoid  p) { m_voidptr = p; }</div>
<div class="line">      </div>
<div class="line">    Void  setValue(Int  idx, Int  val) { <span class="keywordflow">if</span> (idx&gt;=0 &amp;&amp; idx&lt;4) m_val[idx] = val; }</div>
<div class="line">    Int  getValue(Int  idx) { <span class="keywordflow">if</span> (idx&gt;=0 &amp;&amp; idx&lt;4) <span class="keywordflow">return</span>  m_val[idx]; <span class="keywordflow">return</span> -1; }</div>
<div class="line">      </div>
<div class="line">    Void  setPrint(Bool  print) { m_print = print; }</div>
<div class="line">    Bool  getPrint() { <span class="keywordflow">return</span> m_print; }</div>
<div class="line">      </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    pVoid m_voidptr;</div>
<div class="line">    Bool m_print;</div>
<div class="line">    Int m_val[4];</div>
<div class="line">};</div>
</div><!-- fragment --></li>
</ol>
<p><b>NOTE:</b> The custom event data object must provide access to a void pointer and provide definitions for <a class="el" href="classEThreadEventMessageDataBase.html#a54bf958a39d811cd2d2dac47eb842d22">EThreadEventMessageDataBase::getVoidPtr()</a> and <a class="el" href="classEThreadEventMessageDataBase.html#aab7b01e9913284bd9af3d8d510ef892d">EThreadEventMessageDataBase::setVoidPtr()</a>.</p>
<ol type="1">
<li>Define the custom event message class by deriving a class from <a class="el" href="classEThreadEventMessageBase.html">EThreadEventMessageBase</a> utilizing the custom event data class previously defined. <div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classEThreadEventMessageBase.html">EThreadEventMessageBase&lt;MyCustomEventData&gt;</a> MyCustomEvent;</div>
</div><!-- fragment --></li>
<li>Define the custom event queue class utilizing the previously defined custom event message class. <div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classEThreadQueuePublic.html">EThreadQueuePublic&lt;MyCustomEvent&gt;</a> MyCustomEventPublicQueue;</div>
</div><!-- fragment --></li>
<li>Finally, define the custom thread class that will utilize the previously defined custom event queue class. <div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classEThreadEvent.html">EThreadEvent&lt;MyCustomEventPublicQueue, MyCustomEvent&gt;</a> MyCustomThreadEventPublic;</div>
</div><!-- fragment --></li>
<li>Derive a thread class from the newly defined custom thread class and define the message handlers using the custom event message class. <div class="fragment"><div class="line"><span class="keyword">class  </span>MyCustomThread : <span class="keyword">public</span>  MyCustomThreadEventPublic</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    Void  myhandler(MyCustomEvent  &amp;msg)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (msg.data().getPrint())</div>
<div class="line">        {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyCustomThread::myhandler() -&quot;</span></div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot; event=&quot;</span> &lt;&lt; msg.data().getMessageId()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot; m_voidptr=&quot;</span> &lt;&lt; msg.data().getVoidPtr()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot; m_print=&quot;</span> &lt;&lt; (msg.data().getPrint()?<span class="stringliteral">&quot;TRUE&quot;</span>:<span class="stringliteral">&quot;FALSE&quot;</span>)</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot; m_val[0]=&quot;</span> &lt;&lt; msg.data().getValue(0)</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot; m_val[1]=&quot;</span> &lt;&lt; msg.data().getValue(1)</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot; m_val[2]=&quot;</span> &lt;&lt; msg.data().getValue(2)</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot; m_val[3]=&quot;</span> &lt;&lt; msg.data().getValue(3)</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --></li>
</ol>
<p><a class="anchor" id="feature-overview-threads-event-thread-event-processing"></a> </p>
<h4><a class="anchor" id="autotoc_md25"></a>
Event Processing</h4>
<p><b>Standard Events and Callbacks</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Callback Method  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM_INIT  </td><td class="markdownTableBodyNone"><a class="el" href="classEThreadEvent.html#a3003651d73c57459305d073e0f1ad389">onInit()</a>  </td><td class="markdownTableBodyLeft">The EM_INIT message will is posted to the thread when the thread is started. Normally, this is the first message that will be processed. However, for a public thread, it is possible that the process sending thread events could start before the thread is started which would result in the EM_INIT event to not be the first event processed.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM_QUIT  </td><td class="markdownTableBodyNone"><a class="el" href="classEThreadEvent.html#a18fbce94b1fdc44d69cac2ca712fb90e">onQuit()</a>  </td><td class="markdownTableBodyLeft">This event is posted to the thread when the <a class="el" href="classEThreadEvent.html#ad9c48af1f8f68bc7631c547ff2f31757">quit()</a> method is invoked on the thread. This will be the last event processed by the thread before the thread exits.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM_SUSPEND  </td><td class="markdownTableBodyNone"><a class="el" href="classEThreadEvent.html#a8e005870b9f594bfea391b03030d38bd">onSuspend()</a>  </td><td class="markdownTableBodyLeft">This event is posted to a thread when the <a class="el" href="classEThreadEvent.html#a951ebb6aa1c4f060e45272d1aeb80562">suspend()</a> method has been invoked. This will be the last event processed prior to the thread suspending event processing.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM_TIMER  </td><td class="markdownTableBodyNone"><a class="el" href="classEThreadEvent.html#acc26ee3ebe6b5a0e18477c39c01b3c3a">onTimer()</a>  </td><td class="markdownTableBodyLeft">The EM_TIMER event will be posted to a thread when a timer associated with the thread expires. A pointer to the timer object that has expired is included as an argument to the <a class="el" href="classEThreadEvent.html#acc26ee3ebe6b5a0e18477c39c01b3c3a">onTimer()</a> method.   </td></tr>
</table>
<p>User defined events ID's start with EM_USER. The association between the event ID and the event handler is defined in the message map. The following macros are used for declaring the message map and creating the association between the event ID and the event handler.</p>
<p><b>Message Map Macros</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro  </th><th class="markdownTableHeadLeft">Arguments  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="etevent_8h.html#a3e0395c0f948348673c39d06c8bd12bf">DECLARE_MESSAGE_MAP()</a>  </td><td class="markdownTableBodyLeft">None  </td><td class="markdownTableBodyLeft">This macro must appear in the class definition. It's inclusion will create the necessary definitions within the class to support the message map definition and usage.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP()</a>  </td><td class="markdownTableBodyLeft">The class<br  />
The base class  </td><td class="markdownTableBodyLeft">This macro starts the definition of the message map. The first argument is the current class name and the second argument is base class of the current class.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE()</a>  </td><td class="markdownTableBodyLeft">Event ID<br  />
Event handler method  </td><td class="markdownTableBodyLeft">Each user event that is to be handled by the class must have an entry in the message map that establishes the association between the event ID and the event handler method. The event handler method name must be fully qualified.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP()</a>  </td><td class="markdownTableBodyLeft">None  </td><td class="markdownTableBodyLeft">This macro closes the message map declaration.   </td></tr>
</table>
<p>The message map declaration within the class should be performed as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#define  MYEVENT (EM_USER + 1)</span></div>
<div class="line">  </div>
<div class="line"><span class="keyword">class  </span>MyThread : <span class="keyword">public</span>  <a class="code" href="classEThreadEvent.html">EThreadPrivate</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    Void  myhandler(<a class="code" href="classEThreadMessage.html">EThreadMessage</a>  &amp;msg);</div>
<div class="line">    <a class="code" href="etevent_8h.html#a3e0395c0f948348673c39d06c8bd12bf">DECLARE_MESSAGE_MAP</a>()</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><p>The definition of the message map should happen in code as follows: </p><div class="fragment"><div class="line"><a class="code" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a>(MyThread, <a class="code" href="classEThreadEvent.html">EThreadPrivate</a>)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(MYEVENT, MyThread::myhandler)</div>
<div class="line"><a class="code" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a>()</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-threads-event-thread-inheritance"></a> </p>
<h4><a class="anchor" id="autotoc_md26"></a>
Event Dispatching and Inheritance</h4>
<p>When an event is posted to the thread's event queue, the thread will dequeue the event message and call the event handler associated with the event ID. This process is referred to as event dispatching. The association between the event ID and the event handler is defined in the message map.</p>
<div class="fragment"><div class="line"><a class="code" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a>(EThreadTest, <a class="code" href="classEThreadEvent.html">EThreadPrivate</a>)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_USER1, EThreadTest::userFunc1)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_USER2, EThreadTest::userFunc2)</div>
<div class="line"><a class="code" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a>()</div>
</div><!-- fragment --><p> In this example, <code>EThreadTest</code> is derived from <a class="el" href="etevent_8h.html#a8ec0f12a7073f7d1375468685b80b8dd">EThreadPrivate</a> and there are two event handlers defined in <code>EThreadTest</code>: <code>userFunc1()</code> and <code>userFunc2()</code>. According to the message map, when event <code>EM_USER1</code> is received, the dispatcher will call <code>userFunc1()</code> and when <code>EM_USER2</code> is received, the dispatcher will call <code>userFunc2()</code>.</p>
<p>The event dispatcher searches the message map looking for the event ID. If the event ID is not found, the dispatcher will then search the parent class which is the second parameter in the <code>BEGIN_MESSAGE_MAP</code> macro. This process will continue until a handler is identified or there are no more base classes to evaluate. In this case, the <a class="el" href="classEThreadEvent.html">defMessageHandler()</a> will be called to process the message. </p><div class="fragment"><div class="line"><span class="keyword">class  </span>EThreadTestParent : <a class="code" href="classEThreadEvent.html">EThreadPrivate</a></div>
<div class="line">{</div>
<div class="line">    ....</div>
<div class="line">    Void  userFunc1(<a class="code" href="classEThreadMessage.html">EThreadMessage</a>  &amp;msg);</div>
<div class="line">    Void  userFunc2(<a class="code" href="classEThreadMessage.html">EThreadMessage</a>  &amp;msg);</div>
<div class="line">    ....</div>
<div class="line">};</div>
<div class="line">  </div>
<div class="line"><a class="code" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a>(EThreadTestParent, <a class="code" href="classEThreadEvent.html">EThreadPrivate</a>)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_USER1, EThreadTestParent::userFunc1)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_USER2, EThreadTestParent::userFunc2)</div>
<div class="line"><a class="code" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a>()</div>
<div class="line">  </div>
<div class="line">class  EThreadTestChild : public  EThreadTestParent</div>
<div class="line">{</div>
<div class="line">    ....</div>
<div class="line">    Void  childUserFunc1(<a class="code" href="classEThreadMessage.html">EThreadMessage</a>  &amp;msg);</div>
<div class="line">    ....</div>
<div class="line">};</div>
<div class="line">  </div>
<div class="line"><a class="code" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a>(EThreadTestChild, EThreadTestParent)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_USER1, EThreadTestChild::childUserFunc1)</div>
<div class="line"><a class="code" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a>()</div>
</div><!-- fragment --><p>The above example demonstrates the inheritance behavior of the event dispatcher. When an instance of <code>EThreadTestParent</code> is created and <code>EM_USER1</code> is sent to it, <code>EThreadTestParent::userFunc1()</code> will be called to process the event. Similarly, when an instance of <code>EThreadTestChild</code> is created and <code>EM_USER1</code> is sent to it, <code>EThreadTestChild::childUserFunc1()</code> will be called. Finally, when <code>EM_USER2</code> is sent to the instance of <code>EThreadTestChild</code>, the event dispatcher will call <code>EThreadTestParent::userFunc2()</code> to process the event message since there isn't an event handler defined in <code>EThreadTestChild</code> to process <code>EM_USER2</code>.</p>
<p><a class="anchor" id="feature-overview-threads-event-thread-timers"></a> </p>
<h4><a class="anchor" id="autotoc_md27"></a>
Timers</h4>
<p><a class="el" href="classEThreadEvent.html">EThreadEvent</a> supports two types of timers: a periodic timer and a one-shot timer. A periodic timer will emit a timer expiration event X number of milliseconds as defined by the interval of the timer. These timer expiration events will continue until the timer is stopped or destroyed. By contrast, a one-shot timer will generate a single timer expiration event after the duration specified by the timer's interval value.</p>
<p>Both timer types, periodic and one-shot, are represented by the <a class="el" href="classEThreadEventTimer.html">EThreadEventTimer</a> class.</p>
<p><b>Periodic Timer Setup</b> </p><div class="fragment"><div class="line"><a class="code" href="classEThreadEventTimer.html">EThreadEventTimer</a> mytimer;</div>
<div class="line">mytimer.<a class="code" href="classEThreadEventTimer.html#ab95bdb5c96b1ebe5662785282584dbab">setInterval</a>(1000);</div>
<div class="line">mytimer.<a class="code" href="classEThreadEventTimer.html#a6c65cb3297ebc6b37d0aaf8b38445ece">setOneShot</a>(<a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>);</div>
<div class="line">mythread.initTimer(mytimer);</div>
<div class="line">mytimer.<a class="code" href="classEThreadEventTimer.html#afe96e27e5031ae396f1f66160fb9e0ad">start</a>();</div>
</div><!-- fragment --><p>This example will create a periodic timer that will expire once every 1,000 milliseconds (1 second). Each time the timer expires, the onTimer() method of the <code>mythread</code> object will be invoked.</p>
<p><b>One-Shot Timer Setup</b> </p><div class="fragment"><div class="line"><a class="code" href="classEThreadEventTimer.html">EThreadEventTimer</a> mytimer;</div>
<div class="line">mytimer.<a class="code" href="classEThreadEventTimer.html#ab95bdb5c96b1ebe5662785282584dbab">setInterval</a>(1000);</div>
<div class="line">mytimer.<a class="code" href="classEThreadEventTimer.html#a6c65cb3297ebc6b37d0aaf8b38445ece">setOneShot</a>(<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>);</div>
<div class="line">mythread.initTimer(mytimer);</div>
<div class="line">mytimer.<a class="code" href="classEThreadEventTimer.html#afe96e27e5031ae396f1f66160fb9e0ad">start</a>();</div>
</div><!-- fragment --><p>This example will create a one-shot timer that will expire after 1,000 milliseconds (1 second). The timer can be re-used by calling <code>mytimer.start()</code>.</p>
<p>Both periodic and one-shot timers can be stopped by calling the timer <code>stop()</code> method.</p>
<p><a class="anchor" id="feature-overview-threads-event-thread-example"></a> </p>
<h4><a class="anchor" id="autotoc_md28"></a>
Example</h4>
<p>In this example, the has 2 timers that are associated with it, the periodic timer and the overall timer. When the periodic timer expires, for example every 1 second, the onTimer() method will be called which will in turn send the MYEVENT event to the thread which will in turn invoke the myhandler() thread event handler method. When the overall timer expires, for example after 10 seconds, the onTimer() method will call quit() which will trigger the onQuit method to be invoked and the thead will exit. Both timers are initialized and started when the thread is started and invokes the onInit() method. The threadExample() function instantiates the thread and waits for the thread to exit.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define  MYEVENT (EM_USER + 1)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class  </span>MyThread : <span class="keyword">public</span>  <a class="code" href="classEThreadEvent.html">EThreadPrivate</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyThread(Long  periodic_ms, Long  overall_ms)</div>
<div class="line">    {</div>
<div class="line">        m_periodic_ms = periodic_ms;</div>
<div class="line">        m_overall_ms = overall_ms;</div>
<div class="line">        m_count = 0;</div>
<div class="line">    }</div>
<div class="line">      </div>
<div class="line">    Void  <a class="code" href="classEThreadEvent.html#a3003651d73c57459305d073e0f1ad389">onInit</a>()</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; __PRETTY_FUNCTION__</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; invoked&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">          </div>
<div class="line">        std::cout &lt;&lt; <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; __PRETTY_FUNCTION__</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; initializing periodic timer(&quot;</span> &lt;&lt; m_periodic.getId() &lt;&lt; <span class="stringliteral">&quot;) to &quot;</span></div>
<div class="line">            &lt;&lt; m_periodic_ms &lt;&lt; <span class="stringliteral">&quot;ms&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">        m_periodic.setInterval(m_periodic_ms);</div>
<div class="line">        m_periodic.setOneShot(<a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>);</div>
<div class="line">        <a class="code" href="classEThreadEvent.html#ad9dbc8444a26b5865c399f5a075daf2c">initTimer</a>(m_periodic);</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; __PRETTY_FUNCTION__</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; initializing overall timer(&quot;</span> &lt;&lt; m_overall.getId() &lt;&lt; <span class="stringliteral">&quot;) to &quot;</span></div>
<div class="line">            &lt;&lt; m_overall_ms &lt;&lt; <span class="stringliteral">&quot;ms&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">        m_overall.setInterval(m_overall_ms);</div>
<div class="line">        m_overall.setOneShot(<a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>);</div>
<div class="line">        <a class="code" href="classEThreadEvent.html#ad9dbc8444a26b5865c399f5a075daf2c">initTimer</a>(m_overall);</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; __PRETTY_FUNCTION__</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; starting periodic timer&quot;</span> &lt;&lt; <span class="stringliteral">&quot;ms&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">        m_periodic.start();</div>
<div class="line">          </div>
<div class="line">        std::cout &lt;&lt; <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; __PRETTY_FUNCTION__</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; starting overall timer&quot;</span> &lt;&lt; <span class="stringliteral">&quot;ms&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">        m_overall.start();</div>
<div class="line">        m_count = 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Void  <a class="code" href="classEThreadEvent.html#a18fbce94b1fdc44d69cac2ca712fb90e">onQuit</a>()</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; __PRETTY_FUNCTION__</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; invoked - count=&quot;</span> &lt;&lt; m_count &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Void  <a class="code" href="classEThreadEvent.html#acc26ee3ebe6b5a0e18477c39c01b3c3a">onTimer</a>(<a class="code" href="classEThreadEventTimer.html">EThreadEventTimer</a>  *ptimer)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (ptimer-&gt;<a class="code" href="classEThreadEventTimer.html#a4b28f46b10c8164212e2713976f196b1">getId</a>() == m_periodic.getId())</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classEThreadEvent.html#adbdfea9c7c873363a05241dd166fa65b">sendMessage</a>(MYEVENT);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span>  <span class="keywordflow">if</span> (ptimer-&gt;<a class="code" href="classEThreadEventTimer.html#a4b28f46b10c8164212e2713976f196b1">getId</a>() == m_overall.getId())</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classEThreadEvent.html#ad9c48af1f8f68bc7631c547ff2f31757">quit</a>();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">      </div>
<div class="line">    Void  myhandler(<a class="code" href="classEThreadMessage.html">EThreadMessage</a>  &amp;msg)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; __PRETTY_FUNCTION__</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; invoked&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        m_count++;</div>
<div class="line">    }</div>
<div class="line">  </div>
<div class="line">    <a class="code" href="etevent_8h.html#a3e0395c0f948348673c39d06c8bd12bf">DECLARE_MESSAGE_MAP</a>()</div>
<div class="line">  </div>
<div class="line">private:</div>
<div class="line">    MyThread();</div>
<div class="line">    Long m_periodic_ms;</div>
<div class="line">    Long m_overall_ms;</div>
<div class="line">    Int m_count;</div>
<div class="line">    <a class="code" href="classEThreadEventTimer.html">EThreadEventTimer</a> m_periodic;</div>
<div class="line">    <a class="code" href="classEThreadEventTimer.html">EThreadEventTimer</a> m_overall;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a>(MyThread, <a class="code" href="classEThreadEvent.html">EThreadPrivate</a>)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(MYEVENT, MyThread::myhandler)</div>
<div class="line"><a class="code" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a>()</div>
<div class="line">  </div>
<div class="line">Void  threadExample()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> Long periodic_ms = 1000;</div>
<div class="line">    <span class="keyword">static</span> Long overall_ms = 10000;</div>
<div class="line">    Char buffer[128];</div>
<div class="line">    </div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Enter the periodic timer duration in milliseconds [&quot;</span> &lt;&lt; periodic_ms &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span>;</div>
<div class="line">    cin.getline(buffer, <span class="keyword">sizeof</span>(buffer));</div>
<div class="line">    periodic_ms = *buffer ? std::stol(buffer) : periodic_ms;</div>
<div class="line">    </div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Enter the overall timer duration in milliseconds [&quot;</span> &lt;&lt; overall_ms &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span>;</div>
<div class="line">    cin.getline(buffer, <span class="keyword">sizeof</span>(buffer));</div>
<div class="line">    overall_ms = *buffer ? std::stol(buffer) : overall_ms;</div>
<div class="line">    </div>
<div class="line">    MyThread t(periodic_ms, overall_ms);</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt; <span class="stringliteral">&quot; Starting thread example&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    t.init(1,1,NULL);</div>
<div class="line">    t.join();</div>
<div class="line">    std::cout &lt;&lt; <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt; <span class="stringliteral">&quot; Thread example complete&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md29"></a>
Public Event Threads</h3>
<p>The benefit of a public event thread over a private event thread is that thread event messages can be sent from a thread in one process to a thread in another process. This is achieved by storing the event message queue in shared memory. When a process creates an instance of a thread class that has a event message queue derived from <a class="el" href="classEThreadQueuePublic.html">EThreadQueuePublic</a> the event message queue will be stored in shared memory. The application ID and thread ID that the thread is initialized with are used to uniquely identify the event message queue in shared memory.</p>
<p>Here is sample code for the application that will host the public thread. </p><div class="fragment"><div class="line"><span class="keyword">class  </span>MyPublicThread : <span class="keyword">public</span>  <a class="code" href="classEThreadEvent.html">EThreadPublic</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyPublicThread()</div>
<div class="line">    {</div>
<div class="line">        m_count = 0;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    Void  <a class="code" href="classEThreadEvent.html#a3003651d73c57459305d073e0f1ad389">onInit</a>()</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyPublicThread::onInit()&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    Void  <a class="code" href="classEThreadEvent.html#a18fbce94b1fdc44d69cac2ca712fb90e">onQuit</a>()</div>
<div class="line">    {</div>
<div class="line">        m_timer.Stop();</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyPublicThread::onQuit()&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">        <span class="keywordtype">double</span> persec = ((double)m_count) / (((double)m_timer.MicroSeconds()) / 1000000);</div>
<div class="line">        std::string s = numberFormatWithCommas&lt;double&gt;(persec);</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Processed &quot;</span> &lt;&lt; m_count</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; messages in &lt;&lt; ((double)m_timer.MicroSeconds()) / 1000000</span></div>
<div class="line"><span class="stringliteral">            &lt;&lt; &quot;</span>  seconds (<span class="stringliteral">&quot; &lt;&lt; s &lt;&lt; &quot;</span> per second)<span class="stringliteral">&quot; &lt;&lt; std::endl;</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    Void myfunc1(EThreadMessage &amp;msg)</span></div>
<div class="line"><span class="stringliteral">    {</span></div>
<div class="line"><span class="stringliteral">        if (m_count == 0)</span></div>
<div class="line"><span class="stringliteral">            m_timer.Start();</span></div>
<div class="line"><span class="stringliteral">        m_count++;</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    DECLARE_MESSAGE_MAP()</span></div>
<div class="line"><span class="stringliteral">private:</span></div>
<div class="line"><span class="stringliteral">    Int m_count;</span></div>
<div class="line"><span class="stringliteral">    ETimer m_timer;</span></div>
<div class="line"><span class="stringliteral">};</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">BEGIN_MESSAGE_MAP(MyPublicThread, EThreadPublic)</span></div>
<div class="line"><span class="stringliteral">    ON_MESSAGE(MYPUBLICEVENT, MyPublicThread::myfunc1)</span></div>
<div class="line"><span class="stringliteral">END_MESSAGE_MAP()</span></div>
</div><!-- fragment --><p>And here is sample code for the application that will send event messages. </p><div class="fragment"><div class="line">...</div>
<div class="line">EThreadQueuePublic&lt;<a class="code" href="classEThreadMessage.html">EThreadMessage</a>&gt; q;</div>
<div class="line">Long <span class="keywordtype">id</span> = MYPUBLICAPPID * 10000 + MYPUBLICTHREADID;</div>
<div class="line">q.init(queueSize, <span class="keywordtype">id</span>, <a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>, <a class="code" href="etevent_8h.html#a1a7c05eed44a6827c9ffd40fdd92fd50a53dfe5089ae9e65887cb0215cb0098f5">EThreadQueueMode::WriteOnly</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classEThreadMessage.html">EThreadMessage</a> event;</div>
<div class="line"><span class="keyword">event</span>.<a class="code" href="classEThreadEventMessageBase.html#a230c9b28843f770b7cbe41c573516603">data</a>().setMessageId(MYPUBLICEVENT);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (Int idx=0; idx&lt;msgcnt; idx++)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">event</span>.data().data().int64 = idx;</div>
<div class="line">    q.push(event);</div>
<div class="line">}</div>
<div class="line">...</div>
</div><!-- fragment --><p>You will notice that application that will send the messages creates an instance of the thread queue object and the application that will host the thread and process the thread events creates an instance of the thread class.</p>
<p><em><b>NOTE:</b></em> Timing is important. The application that starts first will create the event message queue in shared memory. If this is the application that only sends messages, then it is possible that this application can start posting messages to the event queue before the thread has started. When the application where the thread will exist starts, it will post an <code>EM_INIT</code> message to the thread's event message queue which will trigger the <a class="el" href="classEThreadEvent.html#a3003651d73c57459305d073e0f1ad389">onInit()</a> method to be called. Depending on which application starts first, it is possible that other events will be processed by the thread before the <code>EM_INIT</code> event is processed.</p>
<p><a class="anchor" id="feature-overview-message-queue"></a> </p>
<h2><a class="anchor" id="autotoc_md30"></a>
Message Queue</h2>
<p><a class="anchor" id="feature-overview-message-queue-pack-unpack"></a> </p>
<h3><a class="anchor" id="autotoc_md31"></a>
Pack/Unpack</h3>
<p><a class="anchor" id="feature-overview-synchronization"></a> </p>
<h2><a class="anchor" id="autotoc_md32"></a>
Synchronization</h2>
<p><em><b><a class="el" href="classEpcTools.html" title="The primary class used to initialize/uninitialize EpcTools.">EpcTools</a></b></em> supports several synchronization mechanisms which can be used to synchronize operations in multiple threads and processes. <br  />
 </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type  </th><th class="markdownTableHeadLeft">Private  </th><th class="markdownTableHeadLeft">Public   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Mutex  </td><td class="markdownTableBodyLeft"><a class="el" href="classEMutexPrivate.html">EMutexPrivate</a>  </td><td class="markdownTableBodyLeft"><a class="el" href="classEMutexPublic.html">EMutexPublic</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Semaphore  </td><td class="markdownTableBodyLeft"><a class="el" href="classESemaphorePrivate.html">ESemaphorePrivate</a>  </td><td class="markdownTableBodyLeft"><a class="el" href="classESemaphorePublic.html">ESemaphorePublic</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Event  </td><td class="markdownTableBodyLeft"><a class="el" href="classEEvent.html">EEvent</a>  </td><td class="markdownTableBodyLeft">N/A   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Read/Write Lock  </td><td class="markdownTableBodyLeft"><a class="el" href="classERWLock.html">ERWLock</a>  </td><td class="markdownTableBodyLeft">N/A   </td></tr>
</table>
<p><a class="anchor" id="feature-overview-synchronization-mutex"></a> </p>
<h3><a class="anchor" id="autotoc_md33"></a>
Mutex</h3>
<p>A mutual exclusion or mutex allows for resource sharing by limiting access to that resource to a single thread. An example of this would be to limit adding and removing entries to a linked list to a single thread since performing maintenance on the linked list from multiple threads would most likely cause the list pointers to become corrupted.</p>
<p>A private mutex is allocated from the stack or heap and provides a locking mechanism to threads in the same process. <b>Mutex Example</b> </p><div class="fragment"><div class="line"><a class="code" href="classEMutexPrivate.html">EMutexPrivate</a> m;</div>
</div><!-- fragment --><p>A public mutex is allocated from shared memory and provides synchronization to a single resource across processes. Multiple processes can gain access to the same mutex by attaching to an existing mutex using the mutex ID. The process that creates the mutex does so by simply declaring the mutex. The mutex ID can be retrieved by using the <a class="el" href="classEMutexPublic.html#ab18eafe10a216cffb94fe4dd68bac0da">mutexId()</a> method.</p>
<div class="fragment"><div class="line"><a class="code" href="classEMutexPublic.html">EMutexPublic</a> m;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Mutex ID = &quot;</span>  &lt;&lt;  m.<a class="code" href="classEMutexPublic.html#ab18eafe10a216cffb94fe4dd68bac0da">mutexId</a>() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> Another process can attach to an existing mutex by bypassing the mutex initialization and calling the <a class="el" href="classEMutexPublic.html#ab7ba904a8f25286d03118efaee635e84">attach()</a> method. The method that the "other" process finds out about the mutex ID is up to the application developer. Locking of a public mutex is performed the same way that a private mutex is locked.</p>
<p><b>Public Mutex Attach Example</b> </p><div class="fragment"><div class="line"><a class="code" href="classEMutexPublic.html">EMutexPublic</a> m(<a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>);</div>
<div class="line">m.<a class="code" href="classEMutexPublic.html#ab7ba904a8f25286d03118efaee635e84">attach</a>( mutex_id );</div>
</div><!-- fragment --><p><b>Locking a Mutex</b></p>
<p>A mutex can be locked by creating an instance of <a class="el" href="classEMutexLock.html">EMutexLock</a> which takes a reference to <a class="el" href="classEMutexData.html">EMutexData</a> in it's constructor. Both the <a class="el" href="classEMutexPrivate.html">EMutexPrivate</a> and <a class="el" href="classEMutexPublic.html">EMutexPublic</a> are derived from <a class="el" href="classEMutexData.html">EMutexData</a>, so either object can be passed as the constructor argument. By default, the <a class="el" href="classEMutexLock.html#a3bce7eb1fc8361da74e9fa47e5eff35b">EMutexLock</a> constructor will wait for the lock to be obtained when object is created. However, an optional flag can be passed to the <a class="el" href="classEMutexLock.html#a3bce7eb1fc8361da74e9fa47e5eff35b">EMutexLock</a> constructor to not acquire the lock. In this case, the lock can be manually acquired by calling <a class="el" href="classEMutexLock.html#ab20eb50fd474396c8c71b3c03a472ed2">acquire(Bool wait=True)</a>. If <code>wait</code> is True, <a class="el" href="classEMutexLock.html#ab20eb50fd474396c8c71b3c03a472ed2">acquire()</a> will block until the lock can be obtained. If <code>wait</code> is <code>False</code> and the lock cannot immediately obtained, <a class="el" href="classEMutexLock.html#ab20eb50fd474396c8c71b3c03a472ed2">acquire()</a> will return False indicating that the lock was not obtained.</p>
<p>Regardless of how the lock was obtained, when the <a class="el" href="classEMutexLock.html">EMutexLock</a> object goes out of scope, the lock on the mutex will be released.</p>
<p><b>Mutex Lock Example</b> </p><div class="fragment"><div class="line">...</div>
<div class="line">EMutexPrivate m;</div>
<div class="line">...</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classEMutexLock.html">EMutexLock</a> l(m, <a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>);</div>
<div class="line">    <span class="keywordflow">if</span> (l.acquire(<a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>))</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;The lock has been acquired.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;The lock has NOT been acquired.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-synchronization-semaphore"></a> </p>
<h3><a class="anchor" id="autotoc_md34"></a>
Semaphore</h3>
<p>A counting semaphore is simply a numeric variable that can be incremented and decremented. For example, a semaphore could represent the number of records in a queue or the number of free entries in a pre-allocated array.</p>
<p>A semaphore value can be incremented using the <a class="el" href="classESemaphoreBase.html#a292bce693b058f636c74c9b6eb3ba226">Increment()</a> method, and the semaphore value can be decremented using the <a class="el" href="classESemaphoreBase.html#a4517a1a12b12ca7fe182e77b0532dc5a">Decrement(Bool wait=True)</a> method. When <a class="el" href="classESemaphoreBase.html#a4517a1a12b12ca7fe182e77b0532dc5a">Decrement(Bool wait=True)</a> is called, if the numeric value is zero and <code>wait</code> is <code>True</code>, the function will block until the value is greater than zero before decrementing it. <a class="el" href="classESemaphoreBase.html#a4517a1a12b12ca7fe182e77b0532dc5a">Decrement(Bool wait=True)</a> returns <code>True</code> if the value was successfully decremented and <code>False</code> if the value was not successfully decremented.</p>
<div class="fragment"><div class="line"><span class="comment">// initialize a semaphore with an initial value of 5</span></div>
<div class="line"><a class="code" href="classESemaphorePrivate.html">ESemaphorePrivate</a> s1(5);</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt;  <span class="stringliteral">&quot;Decrementing&quot;</span>;</div>
<div class="line"><span class="keywordflow">for</span> (Int i = 1; i &lt;= 5; i++)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!s1.Decrement())</div>
<div class="line">        std::cout &lt;&lt;  <span class="stringliteral">&quot;Error decrementing semaphore on pass &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt;  <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt;  <span class="stringliteral">&quot;Checking for decrement action at zero...&quot;</span>;</div>
<div class="line"><span class="keywordflow">if</span> (s1.Decrement(<a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>))</div>
<div class="line">    cout &lt;&lt;  <span class="stringliteral">&quot; failed - Decrement returned true&quot;</span>  &lt;&lt; endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    cout &lt;&lt;  <span class="stringliteral">&quot;success&quot;</span>  &lt;&lt; endl;</div>
</div><!-- fragment --><p>A semaphore can be either public or private as represented by <a class="el" href="classESemaphorePublic.html">ESemaphorePublic</a> and <a class="el" href="classESemaphorePrivate.html">ESemaphorePrivate</a>.</p>
<p><a class="anchor" id="feature-overview-synchronization-event"></a> </p>
<h3><a class="anchor" id="autotoc_md35"></a>
Event</h3>
<p>An event object is an object that can be waited on for something to occur. An example could be waiting for a process to complete.</p>
<p><b>Event Example</b> </p><div class="fragment"><div class="line"><span class="keyword">class  </span>EventExampleThread  :  <span class="keyword">public</span> <a class="code" href="classEThreadBasic.html">EThreadBasic</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    EThreadBasicTest()  :  m_timetoquit(false)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Dword <a class="code" href="classEThreadBasic.html#a2af11d0367222ca518151c21f543a6ec">threadProc</a>(Void *arg)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="classEEvent.html">EEvent</a> *ev1 = (<a class="code" href="classEEvent.html">EEvent</a>*)arg;</div>
<div class="line">        ...</div>
<div class="line">        ev1-&gt;<a class="code" href="classEEvent.html#affcbd4245ade48e1973cfd785e2e9f93">set</a>();</div>
<div class="line">        ...</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">    <a class="code" href="classEEvent.html">EEvent</a> ev1;</div>
<div class="line">    EventExampleThread t;</div>
<div class="line">    t.init(&amp;ev1);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;waiting for ev1&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    ev1.<a class="code" href="classEEvent.html#a2b3c1661daa5cd157f49b8cc2ea02bea">wait</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ev1 has been set&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    t.join();</div>
<div class="line">...</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-synchronization-read-write-lock"></a> </p>
<h3><a class="anchor" id="autotoc_md36"></a>
Read/Write Lock</h3>
<p>An Read/Write lock allows concurrent access for read-only operations, while write operations require exclusive access. An example of this is accessing a list would obtain a read lock while updating the list would require a write lock. When a write lock is obtained, it will prevent other read and/or write locks from being granted. Similarly, if a write lock is requested and there is one or more active read locks, the write will only be granted after the read locks have been released.</p>
<p><b>Read/Write Lock Example</b> In this example, two threads will be created that will obtain read locks and a third thread will be created that will obtain a write lock. These threads will run in different combinations that will demonstrate that multiple read locks can be obtained concurrently and only a single exclusive (of other read and write locks) write can be obtained at a time.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define  EM_RWLOCKTEST (EM_USER + 1)</span></div>
<div class="line">  </div>
<div class="line"><span class="keyword">class  </span>ERWLockTestThread : <span class="keyword">public</span>  <a class="code" href="classEThreadEvent.html">EThreadPrivate</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ERWLockTestThread(<a class="code" href="classERWLock.html">ERWLock</a>  &amp;rwl, Bool  reader, cpStr  name)</div>
<div class="line">        : m_rwlock(rwl),</div>
<div class="line">          m_reader(reader),</div>
<div class="line">          m_name(name)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">      </div>
<div class="line">    Void  handleRequest(<a class="code" href="classEThreadMessage.html">EThreadMessage</a>  &amp;msg)</div>
<div class="line">    {</div>
<div class="line">        Int delay = (Int)msg.<a class="code" href="classEThreadEventMessageBase.html#a230c9b28843f770b7cbe41c573516603">data</a>().data().int32[0];</div>
<div class="line">        Int hold = (Int)msg.<a class="code" href="classEThreadEventMessageBase.html#a230c9b28843f770b7cbe41c573516603">data</a>().data().int32[1];</div>
<div class="line">        <a class="code" href="classETimer.html">ETimer</a> tmr;</div>
<div class="line">          </div>
<div class="line">        <a class="code" href="classEThreadBasic.html#a94c06aeb1d4a549f367fda6d39c43a71">EThreadBasic::sleep</a>(delay);</div>
<div class="line">        std::cout &lt;&lt;  <span class="stringliteral">&quot;thread [&quot;</span>  &lt;&lt; m_name &lt;&lt;  <span class="stringliteral">&quot;] starting after &quot;</span></div>
<div class="line">            &lt;&lt; delay &lt;&lt;  <span class="stringliteral">&quot;ms (&quot;</span>  &lt;&lt;  tmr.<a class="code" href="classETimer.html#a83ddc450e6e02c4528c967ac07f0c155">MilliSeconds</a>() &lt;&lt;  <span class="stringliteral">&quot;)&quot;</span>  &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">          </div>
<div class="line">        <span class="keywordflow">if</span> (m_reader)</div>
<div class="line">        {</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;thread [&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="stringliteral">&quot;] waiting for read lock&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">                <span class="comment">// obtain a read lock, the lock will be released when rdlck goes out of scope</span></div>
<div class="line">                <a class="code" href="classERDLock.html">ERDLock</a> rdlck(m_rwlock);</div>
<div class="line">                <a class="code" href="ebase_8h.html#a2017da1a7bf300a2d47bae722cec5e70">epctime_t</a> elapsed =  tmr.<a class="code" href="classETimer.html#a83ddc450e6e02c4528c967ac07f0c155">MilliSeconds</a>();</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;thread [&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="stringliteral">&quot;] read lock obtained after &quot;</span></div>
<div class="line">                    &lt;&lt; elapsed &lt;&lt; <span class="stringliteral">&quot;ms - holding lock for &quot;</span> &lt;&lt; hold &lt;&lt; <span class="stringliteral">&quot;ms&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">                <a class="code" href="classEThreadBasic.html#a94c06aeb1d4a549f367fda6d39c43a71">EThreadBasic::sleep</a>(hold);</div>
<div class="line">            }</div>
<div class="line">            std::cout &lt;&lt;  <span class="stringliteral">&quot;thread [&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="stringliteral">&quot;] read lock released&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;thread [&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="stringliteral">&quot;] waiting for write lock&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">                <span class="comment">// obtain a write lock, the lock will be released when wrlck goes out of scope</span></div>
<div class="line">                <a class="code" href="classEWRLock.html">EWRLock</a> wrlck(m_rwlock);</div>
<div class="line">                <a class="code" href="ebase_8h.html#a2017da1a7bf300a2d47bae722cec5e70">epctime_t</a> elapsed =  tmr.<a class="code" href="classETimer.html#a83ddc450e6e02c4528c967ac07f0c155">MilliSeconds</a>();</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;thread [&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="stringliteral">&quot;] write lock obtained after &quot;</span></div>
<div class="line">                    &lt;&lt; elapsed &lt;&lt; <span class="stringliteral">&quot;ms - holding lock for &quot;</span> &lt;&lt; hold &lt;&lt; <span class="stringliteral">&quot;ms&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">                <a class="code" href="classEThreadBasic.html#a94c06aeb1d4a549f367fda6d39c43a71">EThreadBasic::sleep</a>(hold);</div>
<div class="line">            }</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;thread [&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="stringliteral">&quot;] write lock released&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">      </div>
<div class="line">    <a class="code" href="etevent_8h.html#a3e0395c0f948348673c39d06c8bd12bf">DECLARE_MESSAGE_MAP</a>()</div>
<div class="line">  </div>
<div class="line">private:</div>
<div class="line">    ERWLockTestThread();      </div>
<div class="line">    <a class="code" href="classERWLock.html">ERWLock</a> &amp;m_rwlock;</div>
<div class="line">    Bool m_reader;</div>
<div class="line">    cpStr m_name;</div>
<div class="line">};</div>
<div class="line">  </div>
<div class="line"><a class="code" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a>(ERWLockTestThread, <a class="code" href="classEThreadEvent.html">EThreadPrivate</a>)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_RWLOCKTEST, ERWLockTestThread::handleRequest)</div>
<div class="line"><a class="code" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a>()</div>
<div class="line">  </div>
<div class="line">Void  ERWLock_test()</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ERWLock_test() Start&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      </div>
<div class="line">    <a class="code" href="classERWLock.html">ERWLock</a> rwl;</div>
<div class="line">      </div>
<div class="line">    ERWLockTestThread read1(rwl, <a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>, <span class="stringliteral">&quot;READ1&quot;</span>);</div>
<div class="line">    ERWLockTestThread read2(rwl, <a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>, <span class="stringliteral">&quot;READ2&quot;</span>);</div>
<div class="line">    ERWLockTestThread write1(rwl, <a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>, <span class="stringliteral">&quot;WRITE1&quot;</span>);</div>
<div class="line">      </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ERWLock_test - initializing threads&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">    read1.init(1, 1, NULL, 20000);</div>
<div class="line">    read2.init(1, 2, NULL, 20000);</div>
<div class="line">    write1.init(1, 3, NULL, 20000);</div>
<div class="line">      </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ERWLock_test - starting 1st test&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">    read1.sendMessage(<a class="code" href="classEThreadMessage.html">EThreadMessage</a>(EM_RWLOCKTEST, 0, 4000));</div>
<div class="line">    read2.sendMessage(<a class="code" href="classEThreadMessage.html">EThreadMessage</a>(EM_RWLOCKTEST, 50, 4000));</div>
<div class="line">    write1.sendMessage(<a class="code" href="classEThreadMessage.html">EThreadMessage</a>(EM_RWLOCKTEST, 1000, 4000));</div>
<div class="line">    <a class="code" href="classEThreadBasic.html#a94c06aeb1d4a549f367fda6d39c43a71">EThreadBasic::sleep</a>(10000);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ERWLock_test - 1st test complete&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">      </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ERWLock_test - starting 2nd test&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">    read1.sendMessage(<a class="code" href="classEThreadMessage.html">EThreadMessage</a>(EM_RWLOCKTEST, 1000, 4000));</div>
<div class="line">    read2.sendMessage(<a class="code" href="classEThreadMessage.html">EThreadMessage</a>(EM_RWLOCKTEST, 1050, 4000));</div>
<div class="line">    write1.sendMessage(<a class="code" href="classEThreadMessage.html">EThreadMessage</a>(EM_RWLOCKTEST, 0, 4000));</div>
<div class="line">    <a class="code" href="classEThreadBasic.html#a94c06aeb1d4a549f367fda6d39c43a71">EThreadBasic::sleep</a>(10000);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ERWLock_test - 2nd test complete&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">      </div>
<div class="line">    read1.quit();</div>
<div class="line">    read2.quit();</div>
<div class="line">    write1.quit();</div>
<div class="line">      </div>
<div class="line">    read1.join();</div>
<div class="line">    read2.join();</div>
<div class="line">    write1.join();</div>
<div class="line">      </div>
<div class="line">    std::cout &lt;&lt;  <span class="stringliteral">&quot;ERWLock_test() Complete&quot;</span>  &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-socket-communications"></a> </p>
<h2><a class="anchor" id="autotoc_md37"></a>
Socket Communications</h2>
<p>Asynchronous socket communications is supported by <em><b><a class="el" href="classEpcTools.html" title="The primary class used to initialize/uninitialize EpcTools.">EpcTools</a></b></em> in the <a class="el" href="namespaceESocket.html" title="The namespace for all socket related classes.">ESocket</a> namespace. Currently, support for IPv4 and IPv6 with both TCP and UDP have been implemented. The framework can be enhanced to support additional socket types such as Unix domain socket.</p>
<p><a class="anchor" id="feature-overview-socket-communications-socket-thread"></a> </p>
<h3><a class="anchor" id="autotoc_md38"></a>
Socket Thread</h3>
<p><a class="el" href="classESocket_1_1Thread.html">ESocket::Thread</a> is derived from <a class="el" href="classEThreadEvent.html">EThreadEvent</a> and has a custom message pump and dispatcher to identify and process socket events for sockets that are registered with the socket thread. The message pump function utilizes <code>select()</code> to detect when a socket can be read from, written to or when an error has occurred. These events are then dispatched to appropriate callback methods depending on the role and state of the socket. <br  />
 In addition to processing socket events <a class="el" href="classESocket_1_1Thread.html">ESocket::Thread</a> is also capable of processing standard event messages. See <a href="#feature-overview-threads-event-thread">Event Thread</a> for more information.</p>
<p>Since <a class="el" href="classESocket_1_1Thread.html">ESocket::Thread</a> is derived from <a class="el" href="classEThreadEvent.html">EThreadEvent</a>, <a class="el" href="classESocket_1_1Thread.html">ESocket::Thread</a> supports either a public or a private event message queue with the option of either <a class="el" href="classEThreadMessage.html">EThreadMessage</a> or a custom event thread message.</p>
<p><b>Example Socket Thread</b> </p><div class="fragment"><div class="line"><span class="keyword">class  </span>TcpWorker : <span class="keyword">public</span>  <a class="code" href="classESocket_1_1Thread.html">ESocket::ThreadPrivate</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    TcpWorker()</div>
<div class="line">    {</div>
<div class="line">        m_listen = <a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>;</div>
<div class="line">        m_port =  0;</div>
<div class="line">        m_cnt =  0;</div>
<div class="line">        m_talker =  NULL;</div>
<div class="line">    }</div>
<div class="line">      </div>
<div class="line">    Void  <a class="code" href="classEThreadEvent.html#a3003651d73c57459305d073e0f1ad389">onInit</a>()</div>
<div class="line">    {</div>
<div class="line">        UShort port =  12345;</div>
<div class="line">        <span class="keywordflow">if</span> (getListen())</div>
<div class="line">        {</div>
<div class="line">            m_listener =  <span class="keyword">new</span>  Listener(*<span class="keyword">this</span>);</div>
<div class="line">            m_listener-&gt;listen(port, 10);</div>
<div class="line">            std::cout.imbue(defaultLocale);</div>
<div class="line">            std::cout &lt;&lt;  <span class="stringliteral">&quot;waiting for client to attach on port &quot;</span>  &lt;&lt; port &lt;&lt;  std::endl</div>
<div class="line">                      &lt;&lt;  std::flush;</div>
<div class="line">            std::cout.imbue(mylocale);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            std::cout.imbue(defaultLocale);</div>
<div class="line">            std::cout &lt;&lt;  <span class="stringliteral">&quot;connecting to server on port &quot;</span>  &lt;&lt; port &lt;&lt;  std::endl</div>
<div class="line">                      &lt;&lt;  std::flush;</div>
<div class="line">            std::cout.imbue(mylocale);</div>
<div class="line">            createTalker()-&gt;connect(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 12345);</div>
<div class="line">        }</div>
<div class="line">          </div>
<div class="line">        std::cout &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Void  <a class="code" href="classEThreadEvent.html#a18fbce94b1fdc44d69cac2ca712fb90e">onQuit</a>()</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    Void  onClose()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (m_talker)</div>
<div class="line">        {</div>
<div class="line">            Talker *t = m_talker;</div>
<div class="line">            m_talker =  NULL;</div>
<div class="line">            <span class="keyword">delete</span> t;</div>
<div class="line">            <a class="code" href="classEThreadEvent.html#ad9c48af1f8f68bc7631c547ff2f31757">quit</a>();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    Void  errorHandler(<a class="code" href="classEError.html">EError</a>  &amp;err, <a class="code" href="classESocket_1_1Base.html">ESocket::BasePrivate</a>  *psocket)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//std::cout &lt;&lt; &quot;Socket exception - &quot; &lt;&lt; err &lt;&lt; std::endl &lt;&lt; std::flush;</span></div>
<div class="line">    }     </div>
<div class="line"> </div>
<div class="line">    Talker  *createTalker()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> m_talker =  <span class="keyword">new</span>  Talker(*<span class="keyword">this</span>);</div>
<div class="line">    }     </div>
<div class="line">    </div>
<div class="line">    Void  setListen(Bool  v) { m_listen = v; }</div>
<div class="line">    Bool  getListen() { <span class="keywordflow">return</span> m_listen; }</div>
<div class="line">      </div>
<div class="line">    Void  setCount(Int  cnt) { m_cnt = cnt; }</div>
<div class="line">    Int  getCnt() { <span class="keywordflow">return</span> m_cnt; }</div>
<div class="line">      </div>
<div class="line">    Void  setPort(UShort  port) { m_port = port; }</div>
<div class="line">    UShort  getPort() { <span class="keywordflow">return</span> m_port; }</div>
<div class="line">  </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Bool m_listen;</div>
<div class="line">    UShort m_port;</div>
<div class="line">    Int m_cnt;</div>
<div class="line">    Listener *m_listener;</div>
<div class="line">    Talker *m_talker;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-socket-communications-tcp"></a> </p>
<h3><a class="anchor" id="autotoc_md39"></a>
TCP</h3>
<p>TCP is a streaming connection based protocol. As such, a TCP application will either act as a client (connects to a server) or as a server (accepts connections from clients). The <a class="el" href="namespaceESocket_1_1TCP.html">ESocket::TCP</a> namespace contains the class definitions used by the client and server applications.</p>
<p>A server application listens for incoming connections using a class derived from <a class="el" href="classESocket_1_1TCP_1_1Listener.html">TCP::Listener</a>. When the listener detects an incoming connection, the <a class="el" href="classESocket_1_1TCP_1_1Listener.html#ac2910b7d5739e9291784cc3af4bfab01">TCP::Listener::createSocket()</a> method will be called to create an instance of a class derived from <a class="el" href="classESocket_1_1TCP_1_1Talker.html">TCP::Talker</a> that will be used to received data from and send data to the client.</p>
<p>Conversely, a client application initiates a connection to a server by calling the <a class="el" href="classESocket_1_1TCP_1_1Talker.html#ad4be48c44bed5afc09c823c7c53f6a3d">connect()</a> method with the IP address, IPv4 or IPv6, and port of the server. When the connection is complete, the <a class="el" href="classESocket_1_1TCP_1_1Talker.html#a1f2208e942a66964cc5be4ca1e172aa6">onConnect()</a> method of the socket object will be called by the dispatcher indicating that the connection is up and communication can proceed.</p>
<p><b><a class="el" href="classESocket_1_1TCP_1_1Listener.html">TCP::Listener</a> Events</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Callback Method  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Read  </td><td class="markdownTableBodyNone"><a class="el" href="classESocket_1_1TCP_1_1Talker.html#a1f2208e942a66964cc5be4ca1e172aa6">TCP::Talker::onConnect</a>  </td><td class="markdownTableBodyLeft">A listening socket will indicate that it can be read from when a new client connects. The internals will create a new <a class="el" href="classESocket_1_1TCP_1_1Talker.html">TCP::Talker</a> object to handle the new connection by calling the <a class="el" href="classESocket_1_1TCP_1_1Listener.html#ac2910b7d5739e9291784cc3af4bfab01">TCP::Listener::createSocket()</a> method. Once the talking object has been created, the dispatcher will then call the <a class="el" href="classESocket_1_1TCP_1_1Talker.html#a1f2208e942a66964cc5be4ca1e172aa6">TCP::Talker::onConnect()</a> method to start communication with the new client.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Write  </td><td class="markdownTableBodyNone">None  </td><td class="markdownTableBodyLeft">This event is not applicable to a listening socket.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Error  </td><td class="markdownTableBodyNone"><a class="el" href="classESocket_1_1TCP_1_1Listener.html#a1477b6dd6c8da334612db807d9c22f75">TCP::Listener::onError</a>  </td><td class="markdownTableBodyLeft">Indicates that an error has occurred on the socket while listening for new connections.   </td></tr>
</table>
<p><b>Example TCP Listener</b> </p><div class="fragment"><div class="line"><span class="keyword">class  </span>Listener : <span class="keyword">public</span>  <a class="code" href="classESocket_1_1TCP_1_1Listener.html">ESocket::TCP::ListenerPrivate</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classESocket_1_1TCP_1_1Listener.html#ac459e99dbb89be054d34665ac77b7f78">Listener</a>(TcpWorker  &amp;thread) : <a class="code" href="namespaceESocket.html">ESocket</a>::TCP::<a class="code" href="namespaceESocket_1_1TCP.html#af194efe40cc3fd2948342f083b8b42e2">ListenerPrivate</a>(thread) {}</div>
<div class="line">    <span class="keyword">virtual</span>  <a class="code" href="classESocket_1_1TCP_1_1Listener.html#abb5e0d65fddbc44cfcfdbc6d8404ca97">~Listener</a>() {}</div>
<div class="line">      </div>
<div class="line">    <a class="code" href="classESocket_1_1TCP_1_1Talker.html">ESocket::TCP::TalkerPrivate</a>  *<a class="code" href="classESocket_1_1TCP_1_1Listener.html#ae5e39611743cf6dfac413e6a8d4f67bf">createSocket</a>(<a class="code" href="classESocket_1_1Thread.html">ESocket::ThreadPrivate</a>  &amp;thread)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> ((TcpWorker &amp;)thread).createTalker();</div>
<div class="line">    }</div>
<div class="line">      </div>
<div class="line">    Void  <a class="code" href="classESocket_1_1TCP_1_1Listener.html#a2f9b721b8075770566ca000626d2f03f">onClose</a>()</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;listening socket closed&quot;</span>  &lt;&lt;  std::endl &lt;&lt;  std::flush;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    Void  <a class="code" href="classESocket_1_1TCP_1_1Listener.html#a1477b6dd6c8da334612db807d9c22f75">onError</a>()</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt;  <span class="stringliteral">&quot;socket error &quot;</span>  &lt;&lt;  <a class="code" href="classESocket_1_1Base.html#a9b99ddcf9c8db8c26b7cb5eab79cfb7c">getError</a>()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; occurred on listening socket during select&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classESocket_1_1TCP_1_1Listener.html#ac459e99dbb89be054d34665ac77b7f78">Listener</a>();</div>
<div class="line">};</div>
</div><!-- fragment --><p><b><a class="el" href="classESocket_1_1TCP_1_1Listener.html">TCP::Talker</a> Events</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Callback Method  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Read  </td><td class="markdownTableBodyNone"><a class="el" href="classESocket_1_1TCP_1_1Talker.html#aa2ee361ebd7638ae4a2c2a3c1dc44f39">TCP::Talker::onReceive</a><br  />
<a class="el" href="classESocket_1_1TCP_1_1Talker.html#ab3fbfcfbd4fc5378966ad4362779006c">TCP::Talker::onClose</a>  </td><td class="markdownTableBodyLeft">When a talking socket indicates that it can be read, the framework calls <code>recv()</code> to read any pending data. If zero bytes are read, the socket has been closed and the dispatcher will call the <a class="el" href="classESocket_1_1TCP_1_1Talker.html#ab3fbfcfbd4fc5378966ad4362779006c">TCP::Talker::onClose()</a> method. If more than zero bytes are read, the data is inserted it into an internal receive buffer and the dispatcher will call the <a class="el" href="classESocket_1_1TCP_1_1Talker.html#aa2ee361ebd7638ae4a2c2a3c1dc44f39">TCP::Talker::onReceive()</a> method allowing the application to process the data that has been read.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Write  </td><td class="markdownTableBodyNone">None  </td><td class="markdownTableBodyLeft">The framework processes the write event by attempting to send any unsent data to the peer. No application interaction is required to process this event.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Error  </td><td class="markdownTableBodyNone"><a class="el" href="classESocket_1_1TCP_1_1Talker.html#ade2186d5cc1b4eef1cbb679e28a34895">TCP::Talker::onError</a>  </td><td class="markdownTableBodyLeft">Indicates that an error has occurred on the socket.   </td></tr>
</table>
<p><b>Example TCP Talker</b> </p><div class="fragment"><div class="line"><span class="keyword">class  </span>Talker : <span class="keyword">public</span>  <a class="code" href="classESocket_1_1TCP_1_1Talker.html">ESocket::TCP::TalkerPrivate</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classESocket_1_1TCP_1_1Talker.html#a23c48944af233184985d92c0b155d5ae">Talker</a>(TcpWorker  &amp;thread) : <a class="code" href="namespaceESocket.html">ESocket</a>::TCP::<a class="code" href="namespaceESocket_1_1TCP.html#a6ba05fd575a2c8260b8a447ca63cb2d5">TalkerPrivate</a>(thread) {}</div>
<div class="line">    <a class="code" href="classESocket_1_1TCP_1_1Talker.html#ac5052fac32b4e46a1d0fec4afeb5fcb6">~Talker</a>() {}</div>
<div class="line">      </div>
<div class="line">    Void  <a class="code" href="classESocket_1_1TCP_1_1Talker.html#a1f2208e942a66964cc5be4ca1e172aa6">onConnect</a>()</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="classESocket_1_1TCP_1_1Talker.html#a1f2208e942a66964cc5be4ca1e172aa6">ESocket::TCP::TalkerPrivate::onConnect</a>();</div>
<div class="line">          </div>
<div class="line">        <span class="keywordflow">if</span> (((TcpWorker &amp;)<a class="code" href="classESocket_1_1Base.html#ab9d8e6493e00ee44723d9e62a879052c">getThread</a>()).getListen())</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt;  <span class="stringliteral">&quot;Talker::onConnect() - server connected&quot;</span>  &lt;&lt;  std::endl</div>
<div class="line">                      &lt;&lt;  std::flush;</div>
<div class="line">              </div>
<div class="line">            <a class="code" href="classEString.html">EString</a> localIpAddr =  <a class="code" href="classESocket_1_1TCP_1_1Talker.html#aee324d8b118f582de5ce69cf4e2ec6a8">getLocalAddress</a>();</div>
<div class="line">            UShort localPort =  <a class="code" href="classESocket_1_1TCP_1_1Talker.html#af4e3b0929084c49301d32a115dcde8bf">getLocalPort</a>();</div>
<div class="line">            <a class="code" href="classEString.html">EString</a> remoteIpAddr =  <a class="code" href="classESocket_1_1TCP_1_1Talker.html#a798d06b0be2a1fd8992797534e51b665">getRemoteAddress</a>();</div>
<div class="line">            UShort remotePort =  <a class="code" href="classESocket_1_1TCP_1_1Talker.html#a2a2e9f2861837116aff0c3c96656afdb">getRemotePort</a>();</div>
<div class="line">              </div>
<div class="line">            std::cout.imbue(defaultLocale);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;socket connected&quot;</span></div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot; localIp=&quot;</span> &lt;&lt; localIpAddr &lt;&lt; <span class="stringliteral">&quot; localPort=&quot;</span> &lt;&lt; localPort</div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot; remoteIp=&quot;</span> &lt;&lt; remoteIpAddr &lt;&lt; <span class="stringliteral">&quot; remotePort=&quot;</span> &lt;&lt; remotePort</div>
<div class="line">                      &lt;&lt; std::endl</div>
<div class="line">                      &lt;&lt; std::flush;</div>
<div class="line">            std::cout.imbue(mylocale);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt;  <span class="stringliteral">&quot;Talker::onConnect() - client connected&quot;</span>  &lt;&lt;  std::endl</div>
<div class="line">                      &lt;&lt;  std::flush;</div>
<div class="line">              </div>
<div class="line">            <a class="code" href="classEString.html">EString</a> localIpAddr =  <a class="code" href="classESocket_1_1TCP_1_1Talker.html#aee324d8b118f582de5ce69cf4e2ec6a8">getLocalAddress</a>();</div>
<div class="line">            UShort localPort =  <a class="code" href="classESocket_1_1TCP_1_1Talker.html#af4e3b0929084c49301d32a115dcde8bf">getLocalPort</a>();</div>
<div class="line">            <a class="code" href="classEString.html">EString</a> remoteIpAddr =  <a class="code" href="classESocket_1_1TCP_1_1Talker.html#a798d06b0be2a1fd8992797534e51b665">getRemoteAddress</a>();</div>
<div class="line">            UShort remotePort =  <a class="code" href="classESocket_1_1TCP_1_1Talker.html#a2a2e9f2861837116aff0c3c96656afdb">getRemotePort</a>();</div>
<div class="line">              </div>
<div class="line">            std::cout.imbue(defaultLocale);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;socket connected&quot;</span></div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot; localIp=&quot;</span> &lt;&lt; localIpAddr &lt;&lt; <span class="stringliteral">&quot; localPort=&quot;</span> &lt;&lt; localPort</div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot; remoteIp=&quot;</span> &lt;&lt; remoteIpAddr &lt;&lt; <span class="stringliteral">&quot; remotePort=&quot;</span> &lt;&lt; remotePort</div>
<div class="line">                      &lt;&lt; std::endl</div>
<div class="line">                      &lt;&lt; std::flush;</div>
<div class="line">            std::cout.imbue(mylocale);</div>
<div class="line">              </div>
<div class="line">            <span class="keywordflow">try</span></div>
<div class="line">            {</div>
<div class="line">                Int val =  1;</div>
<div class="line">                <a class="code" href="classESocket_1_1TCP_1_1Talker.html#aaf7cb01536df66dcf51bb34db1a4dd69">write</a>((pUChar)&amp;val, <span class="keyword">sizeof</span>(val));</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">catch</span> (<span class="keyword">const</span>  ESocket::TcpTalkerError_SendingPacket &amp;e)</div>
<div class="line">            {</div>
<div class="line">                std::cerr &lt;&lt; e.what() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> std::flush;</div>
<div class="line">                <a class="code" href="classESocket_1_1Base.html#ab9d8e6493e00ee44723d9e62a879052c">getThread</a>().quit();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    Void  <a class="code" href="classESocket_1_1TCP_1_1Talker.html#aa2ee361ebd7638ae4a2c2a3c1dc44f39">onReceive</a>()</div>
<div class="line">    {</div>
<div class="line">        UChar buffer[1024];</div>
<div class="line">        Int *pval = (Int *)buffer;</div>
<div class="line">          </div>
<div class="line">        <span class="keywordflow">try</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (<a class="code" href="classESocket_1_1TCP_1_1Talker.html#af8b8e2fc6259ff340b5b274105ac9060">bytesPending</a>() &lt;  4  ||  <a class="code" href="classESocket_1_1TCP_1_1Talker.html#ad4b68e850d7e48377060cf52759496af">read</a>(buffer, 4) !=  4)</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">                  </div>
<div class="line">                <span class="keywordflow">if</span> (((TcpWorker &amp;)<a class="code" href="classESocket_1_1Base.html#ab9d8e6493e00ee44723d9e62a879052c">getThread</a>()).getListen())</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">if</span> ((*pval) %  10000  ==  1)</div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;\r&quot;</span> &lt;&lt; *pval -  1 &lt;&lt; std::flush;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">if</span> ((*pval) %  10000  ==  0)</div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;\r&quot;</span> &lt;&lt; *pval &lt;&lt; std::flush;</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span> (*pval !=  -1)</div>
<div class="line">                {</div>
<div class="line">                    *pval = (((TcpWorker &amp;)<a class="code" href="classESocket_1_1Base.html#ab9d8e6493e00ee44723d9e62a879052c">getThread</a>()).getCnt() &gt;  0  &amp;&amp;  *pval &gt;= ((TcpWorker &amp;)<a class="code" href="classESocket_1_1Base.html#ab9d8e6493e00ee44723d9e62a879052c">getThread</a>()).getCnt()) ?  -1  : (*pval +  1);</div>
<div class="line">                    <a class="code" href="classESocket_1_1TCP_1_1Talker.html#aaf7cb01536df66dcf51bb34db1a4dd69">write</a>(buffer, 4);</div>
<div class="line">                }</div>
<div class="line">                  </div>
<div class="line">                <span class="keywordflow">if</span> (*pval ==  -1)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">if</span> (((TcpWorker &amp;)<a class="code" href="classESocket_1_1Base.html#ab9d8e6493e00ee44723d9e62a879052c">getThread</a>()).getListen())</div>
<div class="line">                        <a class="code" href="classESocket_1_1TCP_1_1Talker.html#a5a562f0af552cc6d69db5e056c841733">disconnect</a>();</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span> (<span class="keyword">const</span>  ESocket::TcpTalkerError_SendingPacket &amp;e)</div>
<div class="line">        {</div>
<div class="line">            std::cerr &lt;&lt; e.what() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; std::flush;</div>
<div class="line">            <a class="code" href="classESocket_1_1Base.html#ab9d8e6493e00ee44723d9e62a879052c">getThread</a>().quit();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span> (<span class="keyword">const</span>  std::exception &amp;e)</div>
<div class="line">        {</div>
<div class="line">            std::cerr &lt;&lt; e.what() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; std::flush;</div>
<div class="line">            <a class="code" href="classESocket_1_1Base.html#ab9d8e6493e00ee44723d9e62a879052c">getThread</a>().quit();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    Void  <a class="code" href="classESocket_1_1TCP_1_1Talker.html#ab3fbfcfbd4fc5378966ad4362779006c">onClose</a>()</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;socket closed&quot;</span> &lt;&lt;  std::endl &lt;&lt; std::flush;</div>
<div class="line">        ((TcpWorker &amp;)<a class="code" href="classESocket_1_1Base.html#ab9d8e6493e00ee44723d9e62a879052c">getThread</a>()).<a class="code" href="classESocket_1_1TCP_1_1Talker.html#ab3fbfcfbd4fc5378966ad4362779006c">onClose</a>();</div>
<div class="line">    }  </div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classESocket_1_1TCP_1_1Talker.html#a23c48944af233184985d92c0b155d5ae">Talker</a>();</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-socket-communications-udp"></a> </p>
<h3><a class="anchor" id="autotoc_md40"></a>
UDP</h3>
<p>UDP is a connectionless message based protocol. Messages are sent to specific IP/ports and received from a specific IP/port. A <a class="el" href="classESocket_1_1UDP.html">UDP</a> socket must be bound to a local port and IP address to receive messages.</p>
<p><b>Example UDP Thread</b> </p><div class="fragment"><div class="line"><span class="keyword">class  </span>UdpWorker : <span class="keyword">public</span>  <a class="code" href="classESocket_1_1Thread.html">ESocket::ThreadPrivate</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// In this example, one message will be sent to the peer every second.</span></div>
<div class="line">    UdpWorker()</div>
<div class="line">    {</div>
<div class="line">        m_localport =  0;</div>
<div class="line">        m_remoteport =  0;</div>
<div class="line">        m_cnt =  0;</div>
<div class="line">        m_socket =  NULL;</div>
<div class="line">    }</div>
<div class="line">      </div>
<div class="line">    Void  <a class="code" href="classEThreadEvent.html#a3003651d73c57459305d073e0f1ad389">onInit</a>()</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;creating local UDP socket&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">        m_socket = <span class="keyword">new</span> UdpSocket(*<span class="keyword">this</span>);</div>
<div class="line">          </div>
<div class="line">        std::cout.imbue(defaultLocale);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;binding to IP [&quot;</span> &lt;&lt; getLocalIp()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;] port [&quot;</span> &lt;&lt; getLocalPort() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">        std::cout.imbue(mylocale);</div>
<div class="line">        m_socket-&gt;bind( getLocalIp(), getLocalPort() );</div>
<div class="line">          </div>
<div class="line">        <a class="code" href="classESocket_1_1Address.html">ESocket::Address</a> remote( getRemoteIp(), getRemotePort() );</div>
<div class="line">        m_socket-&gt;setRemote( remote );</div>
<div class="line">        m_socket-&gt;setCount( m_cnt );</div>
<div class="line">          </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;starting the periodic timer&quot;</span> &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">        m_timer.setInterval(1000);</div>
<div class="line">        m_timer.setOneShot(<a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>);</div>
<div class="line">        <a class="code" href="classEThreadEvent.html#ad9dbc8444a26b5865c399f5a075daf2c">initTimer</a>(m_timer);</div>
<div class="line">        m_timer.start();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    Void  <a class="code" href="classEThreadEvent.html#a18fbce94b1fdc44d69cac2ca712fb90e">onQuit</a>()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">delete</span> m_socket;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    Void  errorHandler(<a class="code" href="classEError.html">EError</a>  &amp;err, <a class="code" href="classESocket_1_1Base.html">ESocket::BasePrivate</a>  *psocket)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//std::cout &lt;&lt; &quot;Socket exception - &quot; &lt;&lt; err &lt;&lt; std::endl &lt;&lt; std::flush;</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    Void  setCount(Int  cnt) { m_cnt = cnt; }</div>
<div class="line">    Int  getCount() { <span class="keywordflow">return</span> m_cnt; }</div>
<div class="line">      </div>
<div class="line">    Void  setLocalIp(cpStr  ip) { m_localip = ip; }</div>
<div class="line">    <a class="code" href="classEString.html">EString</a>  &amp;getLocalIp() { <span class="keywordflow">return</span> m_localip; }</div>
<div class="line">    Void  setLocalPort(UShort  port) { m_localport = port; }</div>
<div class="line">    UShort  getLocalPort() { <span class="keywordflow">return</span> m_localport; }</div>
<div class="line">      </div>
<div class="line">    Void  setRemoteIp(cpStr  ip) { m_remoteip = ip; }</div>
<div class="line">    <a class="code" href="classEString.html">EString</a>  &amp;getRemoteIp() { <span class="keywordflow">return</span> m_remoteip; }</div>
<div class="line">    Void  setRemotePort(UShort  port) { m_remoteport = port; }</div>
<div class="line">    UShort  getRemotePort() { <span class="keywordflow">return</span> m_remoteport; }</div>
<div class="line">      </div>
<div class="line">    Void  <a class="code" href="classEThreadEvent.html#acc26ee3ebe6b5a0e18477c39c01b3c3a">onTimer</a>(<a class="code" href="classEThreadEventTimer.html">EThreadEventTimer</a>  *pTimer);</div>
<div class="line">  </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classEString.html">EString</a> m_localip;</div>
<div class="line">    UShort m_localport;</div>
<div class="line">    <a class="code" href="classEString.html">EString</a> m_remoteip;</div>
<div class="line">    UShort m_remoteport;</div>
<div class="line">    Int m_cnt;</div>
<div class="line">    UdpSocket *m_socket;</div>
<div class="line">    <a class="code" href="classEThreadEventTimer.html">EThreadEventTimer</a> m_timer;</div>
<div class="line">};</div>
</div><!-- fragment --><p><b><a class="el" href="classESocket_1_1UDP.html">UDP</a> Events</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Callback Method  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Read  </td><td class="markdownTableBodyNone"><a class="el" href="classESocket_1_1UDP.html#a6dfcc6372f4e8e9acbb2e4685b147d12">UDP::onReceive</a>  </td><td class="markdownTableBodyLeft">When a UDP socket indicates that it can be read, the framework calls <code>recvfrom()</code> to read any pending data. If more than zero bytes are read, the data is inserted it into an internal receive buffer and the dispatcher will call the <a class="el" href="classESocket_1_1UDP.html#a6dfcc6372f4e8e9acbb2e4685b147d12">UDP::onReceive()</a> method allowing the application to process the data that has been read.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Write  </td><td class="markdownTableBodyNone">None  </td><td class="markdownTableBodyLeft">The framework processes the write event by sending any unsent messages to the destination. No application interaction is required to process this event.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Error  </td><td class="markdownTableBodyNone"><a class="el" href="classESocket_1_1UDP.html#a7853433bb2daa353e88263ac62d9e04f">UDP::onError</a>  </td><td class="markdownTableBodyLeft">Indicates that an error has occurred on the socket.   </td></tr>
</table>
<p><b>Example UDP Socket</b> </p><div class="fragment"><div class="line"><span class="keyword">class  </span>UdpSocket : <span class="keyword">public</span>  <a class="code" href="classESocket_1_1UDP.html">ESocket::UdpPrivate</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    UdpSocket(UdpWorker  &amp;thread) : <a class="code" href="namespaceESocket.html">ESocket</a>::<a class="code" href="namespaceESocket.html#a24cc0ce3fc2469d0913def48e8a7f4dd">UdpPrivate</a>(thread)</div>
<div class="line">    {</div>
<div class="line">        m_cnt =  0;</div>
<div class="line">        m_sentcnt =  0;</div>
<div class="line">    }</div>
<div class="line">      </div>
<div class="line">    <span class="keyword">virtual</span>  ~UdpSocket() {}</div>
<div class="line">      </div>
<div class="line">    Void  onReceive(<span class="keyword">const</span> <a class="code" href="classESocket_1_1Address.html">ESocket::Address</a> &amp;from, pVoid msg, Int len)</div>
<div class="line">    {</div>
<div class="line">        std::cout.imbue(defaultLocale);</div>
<div class="line">        std::cout &lt;&lt; <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%Y-%m-%dT%H:%M:%S.%0&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>)</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; Received [&quot;</span> &lt;&lt; *(Int*)pData &lt;&lt; <span class="stringliteral">&quot;] length [&quot;</span> &lt;&lt; length &lt;&lt; <span class="stringliteral">&quot;] from [&quot;</span></div>
<div class="line">            &lt;&lt; addr.getAddress() &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; addr.getPort() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">        std::cout.imbue(mylocale);</div>
<div class="line">          </div>
<div class="line">        <span class="keywordflow">if</span> (*(Int*)pData ==  -1)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (m_sentcnt !=  -1)</div>
<div class="line">            {</div>
<div class="line">                m_sentcnt =  -1;</div>
<div class="line">                sendpacket();</div>
<div class="line">            }</div>
<div class="line">            <a class="code" href="classESocket_1_1Base.html#ab9d8e6493e00ee44723d9e62a879052c">getThread</a>().quit();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    Void  <a class="code" href="classESocket_1_1UDP.html#a7853433bb2daa353e88263ac62d9e04f">onError</a>()</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt;  <span class="stringliteral">&quot;socket error &quot;</span>  &lt;&lt;  <a class="code" href="classESocket_1_1Base.html#a9b99ddcf9c8db8c26b7cb5eab79cfb7c">getError</a>()</div>
<div class="line">            &lt;&lt;  <span class="stringliteral">&quot; occurred on UDP socket during select&quot;</span>  &lt;&lt;  std::endl &lt;&lt;  std::flush;</div>
<div class="line">    }</div>
<div class="line">          </div>
<div class="line">    Void  sendpacket()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (m_sentcnt !=  -1)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (m_sentcnt &lt; m_cnt)</div>
<div class="line">                m_sentcnt++;</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                m_sentcnt =  -1;</div>
<div class="line">        }</div>
<div class="line">        <a class="code" href="classESocket_1_1UDP.html#abb7c08416e17e054fdb1c2af9f18e54c">write</a>( m_remote, &amp;m_sentcnt, <span class="keyword">sizeof</span>(m_sentcnt) );</div>
<div class="line">    }</div>
<div class="line">      </div>
<div class="line">    Void  setCount(Int  cnt) { m_cnt = cnt; }</div>
<div class="line">    Int  getSentCount() { <span class="keywordflow">return</span> m_sentcnt; }</div>
<div class="line">      </div>
<div class="line">    Void  setRemote(<span class="keyword">const</span>  <a class="code" href="classESocket_1_1Address.html">ESocket::Address</a>  addr) { m_remote = addr; }</div>
<div class="line">  </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Int m_cnt;</div>
<div class="line">    Int m_sentcnt;</div>
<div class="line">    <a class="code" href="classESocket_1_1Address.html">ESocket::Address</a> m_remote;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-logging"></a> </p>
<h2><a class="anchor" id="autotoc_md41"></a>
Logging</h2>
<p>Logging in <em><b><a class="el" href="classEpcTools.html" title="The primary class used to initialize/uninitialize EpcTools.">EpcTools</a></b></em> is performed by the <a class="el" href="classELogger.html">ELogger</a> class and configured in the JSON configuration file or in code. Multiple logs can be defined with each log identified by a unique integer identifier (e.g. 1, 2, 99). Each log can have it's messages written to one or more destinations (sinks). The log messages are written by a background thread. The number of threads writing the log messages and the queue size for each thread are defined in the <b>Logger</b> configuration.</p>
<p><a class="anchor" id="feature-overview-logging-configuration"></a> </p>
<h3><a class="anchor" id="autotoc_md42"></a>
Configuration</h3>
<p><a class="anchor" id="feature-overview-logging-configuration-json"></a> </p>
<h4><a class="anchor" id="autotoc_md43"></a>
JSON</h4>
<p>The JSON logger configuration is defined in the <b>Logger</b> configuration section of the <b><a class="el" href="classEpcTools.html" title="The primary class used to initialize/uninitialize EpcTools.">EpcTools</a></b> configuration file. <b>Example JSON Logger Configuration</b> </p><div class="fragment"><div class="line">&quot;EpcTools&quot;: {</div>
<div class="line">    &quot;EnablePublicObjects&quot;: false,</div>
<div class="line">    &quot;Debug&quot;: false,</div>
<div class="line">    &quot;SynchronizationObjects&quot;: {</div>
<div class="line">        &quot;NumberSemaphores&quot;: 100,</div>
<div class="line">        &quot;NumberMutexes&quot;: 100</div>
<div class="line">    },</div>
<div class="line">    &quot;Logger&quot;: {</div>
<div class="line">        &quot;ApplicationName&quot;: &quot;epc_app&quot;,</div>
<div class="line">        &quot;QueueSize&quot;: 8192,</div>
<div class="line">        &quot;NumberThreads&quot;: 1,</div>
<div class="line">        &quot;SinkSets&quot;: [</div>
<div class="line">            {</div>
<div class="line">                &quot;SinkID&quot;: 1,</div>
<div class="line">                &quot;Sinks&quot;: [</div>
<div class="line">                    {</div>
<div class="line">                        &quot;SinkType&quot;: &quot;syslog&quot;,</div>
<div class="line">                        &quot;LogLevel&quot;: &quot;startup&quot;,</div>
<div class="line">                        &quot;Pattern&quot;: &quot;[__APPNAME__] [%n] [%l] %v&quot;</div>
<div class="line">                    },</div>
<div class="line">                    {</div>
<div class="line">                        &quot;SinkType&quot;: &quot;stdout&quot;,</div>
<div class="line">                        &quot;LogLevel&quot;: &quot;debug&quot;,</div>
<div class="line">                        &quot;Pattern&quot;: &quot;[%Y-%m-%dT%H:%M:%S.%e] [stdout] [%^__APPNAME__%$] [%n] [%^%l%$] %v&quot;</div>
<div class="line">                    },</div>
<div class="line">                    {</div>
<div class="line">                        &quot;SinkType&quot;: &quot;stderr&quot;,</div>
<div class="line">                        &quot;LogLevel&quot;: &quot;minor&quot;,</div>
<div class="line">                        &quot;Pattern&quot;: &quot;[%Y-%m-%dT%H:%M:%S.%e] [stderr] [%^__APPNAME__%$] [%n] [%^%l%$] %v&quot;</div>
<div class="line">                    },</div>
<div class="line">                    {</div>
<div class="line">                        &quot;SinkType&quot;: &quot;basic_file&quot;,</div>
<div class="line">                        &quot;LogLevel&quot;: &quot;debug&quot;,</div>
<div class="line">                        &quot;Pattern&quot;: &quot;[%Y-%m-%dT%H:%M:%S.%e] [%^__APPNAME__%$] [%n] [%^%l%$] %v&quot;,</div>
<div class="line">                        &quot;FileName&quot;: &quot;./logs/epctest.basic.log&quot;,</div>
<div class="line">                        &quot;Truncate&quot;: false</div>
<div class="line">                    },</div>
<div class="line">                    {</div>
<div class="line">                        &quot;SinkType&quot;: &quot;rotating_file&quot;,</div>
<div class="line">                        &quot;LogLevel&quot;: &quot;debug&quot;,</div>
<div class="line">                        &quot;Pattern&quot;: &quot;[%Y-%m-%dT%H:%M:%S.%e] [%^__APPNAME__%$] [%n] [%^%l%$] %v&quot;,</div>
<div class="line">                        &quot;FileName&quot;: &quot;./logs/epctest.rotating.log&quot;,</div>
<div class="line">                        &quot;MaxSizeMB&quot;: 1,</div>
<div class="line">                        &quot;MaxNumberFiles&quot;: 2,</div>
<div class="line">                        &quot;RotateOnOpen&quot;: false</div>
<div class="line">                    },</div>
<div class="line">                    {</div>
<div class="line">                        &quot;SinkType&quot;: &quot;daily_file&quot;,</div>
<div class="line">                        &quot;LogLevel&quot;: &quot;debug&quot;,</div>
<div class="line">                        &quot;Pattern&quot;: &quot;[%Y-%m-%dT%H:%M:%S.%e] [%^__APPNAME__%$] [%n] [%^%l%$] %v&quot;,</div>
<div class="line">                        &quot;FileName&quot;: &quot;./logs/epctest.daily.log&quot;,</div>
<div class="line">                        &quot;Truncate&quot;: false,</div>
<div class="line">                        &quot;RolloverHour&quot;: 14,</div>
<div class="line">                        &quot;RolloverMinute&quot;: 55</div>
<div class="line">                    }</div>
<div class="line">                ]</div>
<div class="line">            },</div>
<div class="line">            {</div>
<div class="line">                &quot;SinkID&quot;: 2,</div>
<div class="line">                &quot;Sinks&quot;: [</div>
<div class="line">                    {</div>
<div class="line">                        &quot;SinkType&quot;: &quot;rotating_file&quot;,</div>
<div class="line">                        &quot;LogLevel&quot;: &quot;debug&quot;,</div>
<div class="line">                        &quot;Pattern&quot;: &quot;%v&quot;,</div>
<div class="line">                        &quot;FileName&quot;: &quot;./logs/epctest.stats.rotating.log&quot;,</div>
<div class="line">                        &quot;MaxSizeMB&quot;: 1,</div>
<div class="line">                        &quot;MaxNumberFiles&quot;: 2</div>
<div class="line">                    }</div>
<div class="line">                ]</div>
<div class="line">            }</div>
<div class="line">        ],</div>
<div class="line">        &quot;Logs&quot;: [</div>
<div class="line">            {</div>
<div class="line">                &quot;LogID&quot;: 1,</div>
<div class="line">                &quot;Category&quot;: &quot;system&quot;,</div>
<div class="line">                &quot;SinkID&quot;: 1,</div>
<div class="line">                &quot;LogLevel&quot;: &quot;debug&quot;</div>
<div class="line">            },</div>
<div class="line">            {</div>
<div class="line">                &quot;LogID&quot;: 2,</div>
<div class="line">                &quot;Category&quot;: &quot;test1&quot;,</div>
<div class="line">                &quot;SinkID&quot;: 1,</div>
<div class="line">                &quot;LogLevel&quot;: &quot;debug&quot;</div>
<div class="line">            },</div>
<div class="line">            {</div>
<div class="line">                &quot;LogID&quot;: 3,</div>
<div class="line">                &quot;Category&quot;: &quot;stats&quot;,</div>
<div class="line">                &quot;SinkID&quot;: 2,</div>
<div class="line">                &quot;LogLevel&quot;: &quot;debug&quot;</div>
<div class="line">            }</div>
<div class="line">        ]</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>JSON Configuration Elements</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Callback Method  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Read  </td><td class="markdownTableBodyNone"><a class="el" href="classESocket_1_1UDP.html#a6dfcc6372f4e8e9acbb2e4685b147d12">UDP::onReceive</a>  </td><td class="markdownTableBodyLeft">When a UDP socket indicates that it can be read, the framework calls <code>recvfrom()</code> to read any pending data. If more than zero bytes are read, the data is inserted it into an internal receive buffer and the dispatcher will call the <a class="el" href="classESocket_1_1UDP.html#a6dfcc6372f4e8e9acbb2e4685b147d12">UDP::onReceive()</a> method allowing the application to process the data that has been read.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Write  </td><td class="markdownTableBodyNone">None  </td><td class="markdownTableBodyLeft">The framework processes the write event by sending any unsent messages to the destination. No application interaction is required to process this event.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Error  </td><td class="markdownTableBodyNone"><a class="el" href="classESocket_1_1UDP.html#a7853433bb2daa353e88263ac62d9e04f">UDP::onError</a>  </td><td class="markdownTableBodyLeft">Indicates that an error has occurred on the socket.   </td></tr>
</table>
<p><a class="anchor" id="feature-overview-logging-configuration-code"></a> </p>
<h4><a class="anchor" id="autotoc_md44"></a>
Code</h4>
<p>The following code configures <a class="el" href="classELogger.html">ELogger</a> the same as the <a href="#feature-overview-logging-configuration-json">JSON</a> configuration example.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define LOG_SINKSET_GENERAL 1</span></div>
<div class="line"><span class="preprocessor">#define LOG_SINKSET_STATS 2</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define LOG_SYSTEM 1</span></div>
<div class="line"><span class="preprocessor">#define LOG_TEST1 2</span></div>
<div class="line"><span class="preprocessor">#define LOG_STATS 3</span></div>
<div class="line">  </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">std::shared_ptr&lt;<a class="code" href="classELoggerSink.html">ELoggerSink</a>&gt; sp1 = std::make_shared&lt;ELoggerSinkSyslog&gt;(</div>
<div class="line">    <a class="code" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a70c3ea4d2caebd12b06270bb858acb61">ELogger::eStartup</a>, <span class="stringliteral">&quot;[__APPNAME__] [%n] [%l] %v&quot;</span> );</div>
<div class="line">std::shared_ptr&lt;ELoggerSink&gt; sp2 = std::make_shared&lt;ELoggerSinkStdout&gt;(</div>
<div class="line">    <a class="code" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a1f0f01a3b5937718bea0102b7048dd26">ELogger::eDebug</a>, <span class="stringliteral">&quot;[%Y-%m-%dT%H:%M:%S.%e] [stdout] [%^__APPNAME__%$] [%n] [%^%l%$] %v&quot;</span> );</div>
<div class="line">std::shared_ptr&lt;ELoggerSink&gt; sp3 = std::make_shared&lt;ELoggerSinkStderr&gt;(</div>
<div class="line">    <a class="code" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a17c9da6fdf1a7e126bf4a5ac16fe830e">ELogger::eMinor</a>, <span class="stringliteral">&quot;[%Y-%m-%dT%H:%M:%S.%e] [stderr] [%^__APPNAME__%$] [%n] [%^%l%$] %v&quot;</span> );</div>
<div class="line">std::shared_ptr&lt;ELoggerSink&gt; sp4 = std::make_shared&lt;ELoggerSinkBasicFile&gt;(</div>
<div class="line">    <a class="code" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a1f0f01a3b5937718bea0102b7048dd26">ELogger::eDebug</a>, <span class="stringliteral">&quot;[%Y-%m-%dT%H:%M:%S.%e] [%^__APPNAME__%$] [%n] [%^%l%$] %v&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;./logs/epctest.basic.log&quot;</span>, <a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a> );</div>
<div class="line">std::shared_ptr&lt;ELoggerSink&gt; sp5 = std::make_shared&lt;ELoggerSinkRotatingFile&gt;(</div>
<div class="line">    <a class="code" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a1f0f01a3b5937718bea0102b7048dd26">ELogger::eDebug</a>, <span class="stringliteral">&quot;[%Y-%m-%dT%H:%M:%S.%e] [%^__APPNAME__%$] [%n] [%^%l%$] %v&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;./logs/epctest.rotating.log&quot;</span>, 10, 2, <span class="keyword">false</span> );</div>
<div class="line">std::shared_ptr&lt;ELoggerSink&gt; sp6 = std::make_shared&lt;ELoggerSinkDailyFile&gt;(</div>
<div class="line">    <a class="code" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a1f0f01a3b5937718bea0102b7048dd26">ELogger::eDebug</a>, <span class="stringliteral">&quot;[%Y-%m-%dT%H:%M:%S.%e] [%^__APPNAME__%$] [%n] [%^%l%$] %v&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;./logs/epctest.daily.log&quot;</span>, <span class="keyword">false</span>, 14, 55 );</div>
<div class="line">std::shared_ptr&lt;ELoggerSink&gt; sp7 = std::make_shared&lt;ELoggerSinkRotatingFile&gt;(</div>
<div class="line">    <a class="code" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a1f0f01a3b5937718bea0102b7048dd26">ELogger::eDebug</a>, <span class="stringliteral">&quot;%v&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;./logs/epctest.stats.rotating.log&quot;</span>, 10, 2, <span class="keyword">false</span> );</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classELogger.html#a1c628d5920ebdcc9593ac1413be45a94">ELogger::createSinkSet</a>( LOG_SINKSET_GENERAL );</div>
<div class="line"><a class="code" href="classELogger.html#a16b8ce5b92cfcb542abe981e481e2b77">ELogger::sinkSet</a>(LOG_SINKSET_GENERAL).<a class="code" href="classELoggerSinkSet.html#a388a73618efe1cacb7e7481555040411">addSink</a>( sp1 );</div>
<div class="line"><a class="code" href="classELogger.html#a16b8ce5b92cfcb542abe981e481e2b77">ELogger::sinkSet</a>(LOG_SINKSET_GENERAL).<a class="code" href="classELoggerSinkSet.html#a388a73618efe1cacb7e7481555040411">addSink</a>( sp2 );</div>
<div class="line"><a class="code" href="classELogger.html#a16b8ce5b92cfcb542abe981e481e2b77">ELogger::sinkSet</a>(LOG_SINKSET_GENERAL).<a class="code" href="classELoggerSinkSet.html#a388a73618efe1cacb7e7481555040411">addSink</a>( sp3 );</div>
<div class="line"><a class="code" href="classELogger.html#a16b8ce5b92cfcb542abe981e481e2b77">ELogger::sinkSet</a>(LOG_SINKSET_GENERAL).<a class="code" href="classELoggerSinkSet.html#a388a73618efe1cacb7e7481555040411">addSink</a>( sp4 );</div>
<div class="line"><a class="code" href="classELogger.html#a16b8ce5b92cfcb542abe981e481e2b77">ELogger::sinkSet</a>(LOG_SINKSET_GENERAL).<a class="code" href="classELoggerSinkSet.html#a388a73618efe1cacb7e7481555040411">addSink</a>( sp5 );</div>
<div class="line"><a class="code" href="classELogger.html#a16b8ce5b92cfcb542abe981e481e2b77">ELogger::sinkSet</a>(LOG_SINKSET_GENERAL).<a class="code" href="classELoggerSinkSet.html#a388a73618efe1cacb7e7481555040411">addSink</a>( sp6 );</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classELogger.html#a1c628d5920ebdcc9593ac1413be45a94">ELogger::createSinkSet</a>( LOG_SINKSET_STATS );</div>
<div class="line"><a class="code" href="classELogger.html#a16b8ce5b92cfcb542abe981e481e2b77">ELogger::sinkSet</a>(LOG_SINKSET_STATS).<a class="code" href="classELoggerSinkSet.html#a388a73618efe1cacb7e7481555040411">addSink</a>( sp7 );</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classELogger.html#a5a215d97bbcce4d538a49a096dc7ef68">ELogger::createLog</a>( LOG_SYSTEM, <span class="stringliteral">&quot;system&quot;</span>, LOG_SINKSET_GENERAL );</div>
<div class="line"><a class="code" href="classELogger.html#a5a215d97bbcce4d538a49a096dc7ef68">ELogger::createLog</a>( LOG_TEST1, <span class="stringliteral">&quot;test1&quot;</span>, LOG_SINKSET_GENERAL );</div>
<div class="line"><a class="code" href="classELogger.html#a5a215d97bbcce4d538a49a096dc7ef68">ELogger::createLog</a>( LOG_STATS, <span class="stringliteral">&quot;stats&quot;</span>, LOG_SINKSET_STATS );</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classELogger.html#a94a47d71f929233a7100d573732e3cd9">ELogger::log</a>(LOG_SYSTEM).<a class="code" href="classELogger.html#a7656e745ab38929f87ec9a50e355ab3d">setLogLevel</a>( <a class="code" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a1f0f01a3b5937718bea0102b7048dd26">ELogger::eDebug</a> );</div>
<div class="line"><a class="code" href="classELogger.html#a94a47d71f929233a7100d573732e3cd9">ELogger::log</a>(LOG_TEST1).<a class="code" href="classELogger.html#a7656e745ab38929f87ec9a50e355ab3d">setLogLevel</a>( <a class="code" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a1f0f01a3b5937718bea0102b7048dd26">ELogger::eDebug</a> );</div>
<div class="line"><a class="code" href="classELogger.html#a94a47d71f929233a7100d573732e3cd9">ELogger::log</a>(LOG_STATS).<a class="code" href="classELogger.html#a7656e745ab38929f87ec9a50e355ab3d">setLogLevel</a>( <a class="code" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a1f0f01a3b5937718bea0102b7048dd26">ELogger::eDebug</a> );</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-logging-configuration-sinksets"></a> </p>
<h4><a class="anchor" id="autotoc_md45"></a>
Sink Sets</h4>
<p>A sink set defines a set of outputs or sinks. Once defined, a sink set is then associated with a log. If the same sink set is associated with more than one log, then each of the associated logs will have their log messages written to the same sinks.</p>
<p><b>Sink Types</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Class  </th><th class="markdownTableHeadNone">Parameters  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classELoggerSinkSyslog.html">ELoggerSinkSyslog</a>  </td><td class="markdownTableBodyNone">loglevel<br  />
pattern  </td><td class="markdownTableBodyLeft">Message will be written to syslog.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classELoggerSinkStdout.html">ELoggerSinkStdout</a>  </td><td class="markdownTableBodyNone">loglevel<br  />
pattern  </td><td class="markdownTableBodyLeft">Message will be written to the standard output (stdout) file handle.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classELoggerSinkStderr.html">ELoggerSinkStderr</a>  </td><td class="markdownTableBodyNone">loglevel<br  />
pattern  </td><td class="markdownTableBodyLeft">Message will be written to the standard error (stderr) file handle.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classELoggerSinkBasicFile.html">ELoggerSinkBasicFile</a>  </td><td class="markdownTableBodyNone">loglevel<br  />
pattern<br  />
filename<br  />
truncate  </td><td class="markdownTableBodyLeft">Message will be written to a file. If the <b>truncate</b> flag is true, then the file will be truncated at startup.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classELoggerSinkRotatingFile.html">ELoggerSinkRotatingFile</a>  </td><td class="markdownTableBodyNone">loglevel<br  />
pattern<br  />
filename<br  />
max_size_mb<br  />
max_files<br  />
rotate_on_open  </td><td class="markdownTableBodyLeft">Message will be written to a series of files. When a file reaches the maximum file size defined by <b>max_size_mb</b>, the next file in the series will be opened and written to. <a class="el" href="classELogger.html" title="Defines a logger.">ELogger</a> will keep a maximum of <b>max_files</b> previous log files (including the current file).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classELoggerSinkDailyFile.html">ELoggerSinkDailyFile</a>  </td><td class="markdownTableBodyNone">loglevel<br  />
pattern<br  />
filename<br  />
truncate<br  />
rollover_hour<br  />
rollover_minute  </td><td class="markdownTableBodyLeft">Message will be written to a file. When the hour and minute specified by <b>rollover_hour</b> and <b>rollover_minute</b> are reached, the current log file will be closed and a new log file will be opened. The system date and time will be appended to the log file name.   </td></tr>
</table>
<p><a class="anchor" id="feature-overview-logging-configuration-logs"></a> </p>
<h4><a class="anchor" id="autotoc_md46"></a>
Logs</h4>
<p>A log definition includes a log <b>category</b>, a string that can be output with each log message, a <b>sink set</b> which defines the sinks that the log messages will be written to, a <b>log identifier</b> used to identify the log when writing a log message and the minimum <b>log level</b> at which log messages will be written to associated sink set sinks.</p>
<p><a class="anchor" id="feature-overview-logging-configuration-loglevels"></a> </p>
<h4><a class="anchor" id="autotoc_md47"></a>
Log Levels</h4>
<p>When a log message is written a <b>log level</b> is included that represents the severity or importance of the log message. Each <b>sink</b> and <b>log</b> also has a log level associated with it. These log levels represent the minimum log level that will be output to the <b>sink</b> or <b>log</b>.</p>
<p><b>Log Levels in Ascending Order of Importance</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Log Level  </th><th class="markdownTableHeadNone">Enumeration   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Debug  </td><td class="markdownTableBodyNone"><a class="el" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a1f0f01a3b5937718bea0102b7048dd26">ELogger::eDebug</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Informational  </td><td class="markdownTableBodyNone"><a class="el" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968ad33bdb958ce9a7f75bd8f8db1f5b13be">ELogger::eInfo</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Startup  </td><td class="markdownTableBodyNone"><a class="el" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a70c3ea4d2caebd12b06270bb858acb61">ELogger::eStartup</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Minor  </td><td class="markdownTableBodyNone"><a class="el" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a17c9da6fdf1a7e126bf4a5ac16fe830e">ELogger::eMinor</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Major  </td><td class="markdownTableBodyNone"><a class="el" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968ad69a71ad50b3acc044fd0598e0721a14">ELogger::eMajor</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Critical  </td><td class="markdownTableBodyNone"><a class="el" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a770b56350aec9e8d2bf424fab98dec43">ELogger::eCritical</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Off (suppresses all messages)  </td><td class="markdownTableBodyNone"><a class="el" href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a725ff2a12b723ead3ade51c59207f600">ELogger::eOff</a>   </td></tr>
</table>
<p><a class="anchor" id="feature-overview-logging-logmessages"></a> </p>
<h3><a class="anchor" id="autotoc_md48"></a>
Log Messages</h3>
<p><b>Examples</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#define LOG_SYSTEM 1</span></div>
<div class="line"><span class="preprocessor">#define LOG_TEST1 2</span></div>
<div class="line"><span class="preprocessor">#define LOG_STATS 3</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classELogger.html#a94a47d71f929233a7100d573732e3cd9">ELogger::log</a>(LOG_SYSTEM).<a class="code" href="classELogger.html#a06d60680bbf6cf1b235545786effb1bb">minor</a>(<span class="stringliteral">&quot;Hello Wonderful World from the system log!!&quot;</span>);</div>
<div class="line"><span class="comment">// ELoggerSinkSyslog</span></div>
<div class="line"><span class="comment">// Jan 23 18:12:54 dev epctest: [epctest] [system] [minor] Hello World from the system log!!</span></div>
<div class="line"><span class="comment">// ELoggerSinkStdout</span></div>
<div class="line"><span class="comment">// [2020-01-23T18:12:54.944] [stdout] [epctest] [system] [minor] Hello World from the system log!!</span></div>
<div class="line"><span class="comment">// ELoggerSinkStderr</span></div>
<div class="line"><span class="comment">// [2020-01-23T18:12:54.944] [stderr] [epctest] [system] [minor] Hello World from the system log!!</span></div>
<div class="line"><span class="comment">// ELoggerSinkBasicFile</span></div>
<div class="line"><span class="comment">// [2020-01-23T18:12:54.944] [epctest] [system] [minor] Hello World from the system log!!</span></div>
<div class="line"><span class="comment">// ELoggerSinkRotatingFile</span></div>
<div class="line"><span class="comment">// [2020-01-23T18:12:54.944] [epctest] [system] [minor] Hello World from the system log!!</span></div>
<div class="line"><span class="comment">// ELoggerSinkDailyFile</span></div>
<div class="line"><span class="comment">// [2020-01-23T18:12:54.944] [epctest] [system] [minor] Hello World from the system log!!</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classELogger.html#a94a47d71f929233a7100d573732e3cd9">ELogger::log</a>(LOG_TEST1).<a class="code" href="classELogger.html#a3b04b024d3ba2c8ca119e4ff5cc2f6a7">startup</a>(<span class="stringliteral">&quot;Hello {} from the test1 log!!&quot;</span>, <span class="stringliteral">&quot;World&quot;</span>);</div>
<div class="line"><span class="comment">// ELoggerSinkSyslog</span></div>
<div class="line"><span class="comment">// Jan 23 18:12:54 dev epctest: [epctest] [test1] [startup] Hello World from the test1 log!!</span></div>
<div class="line"><span class="comment">// ELoggerSinkStdout</span></div>
<div class="line"><span class="comment">// [2020-01-23T18:12:54.944] [stdout] [epctest] [test1] [startup] Hello World from the test1 log!!</span></div>
<div class="line"><span class="comment">// ELoggerSinkStderr</span></div>
<div class="line"><span class="comment">// [2020-01-23T18:12:54.944] [stderr] [epctest] [test1] [startup] Hello World from the test1 log!!</span></div>
<div class="line"><span class="comment">// ELoggerSinkBasicFile (epctest.basic.log)</span></div>
<div class="line"><span class="comment">// [2020-01-23T18:12:54.944] [epctest] [test1] [startup] Hello World from the test1 log!!</span></div>
<div class="line"><span class="comment">// ELoggerSinkRotatingFile (epctest.rotating.log)</span></div>
<div class="line"><span class="comment">// [2020-01-23T18:12:54.944] [epctest] [test1] [startup] Hello World from the test1 log!!</span></div>
<div class="line"><span class="comment">// ELoggerSinkDailyFile (epctest.daily_2020-01-23.log)</span></div>
<div class="line"><span class="comment">// [2020-01-23T18:12:54.944] [epctest] [test1] [startup] Hello World from the test1 log!!</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classELogger.html#a94a47d71f929233a7100d573732e3cd9">ELogger::log</a>(LOG_STATS).<a class="code" href="classELogger.html#a06d60680bbf6cf1b235545786effb1bb">minor</a>(<span class="stringliteral">&quot;Hello {} from the test2 log!!&quot;</span>, <span class="stringliteral">&quot;World&quot;</span>);</div>
<div class="line"><span class="comment">// ELoggerSinkRotatingFile (epctest.stats.rotating.log)</span></div>
<div class="line"><span class="comment">// Hello World from the test2 log!!</span></div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-dns"></a> </p>
<h2><a class="anchor" id="autotoc_md49"></a>
DNS</h2>
<p><a class="anchor" id="feature-overview-dns-cache"></a> </p>
<h3><a class="anchor" id="autotoc_md50"></a>
DNS Cache</h3>
<p>A <a class="el" href="namespaceDNS.html">DNS</a> Cache, represented by <a class="el" href="classDNS_1_1Cache.html">DNS::Cache</a>, is defined as one or more <a class="el" href="namespaceDNS.html">DNS</a> servers that can provide access to the same information. This set of <a class="el" href="namespaceDNS.html">DNS</a> servers is represented by a cache identifier, a unique integer. Accessing the cache instance, <a class="el" href="classDNS_1_1Cache.html#a651dac5179ee4e53dbe1ae4896dd41d3">DNS::Cache::getInstance()</a>, will create the <a class="el" href="namespaceDNS.html">DNS</a> cache if it does not already exist.</p>
<p>The first step in preparing a <a class="el" href="namespaceDNS.html">DNS</a> cache for use is to configure the global settings as it relates to refreshing entries in the cache based on their TTL (time to live). Queries that have been previously processed by a <a class="el" href="namespaceDNS.html">DNS</a> cache are refreshed prior to their expiration time. This ensures that if the same query is executed that the results will come from the cache instead of having to wait for the query to be sent to a <a class="el" href="namespaceDNS.html">DNS</a> server. The refresh process occurs in the background.</p>
<div class="fragment"><div class="line"><a class="code" href="classDNS_1_1Cache.html#ae2be30116662b904388fc43bf89e0ca0">DNS::Cache::setRefreshConcurrent</a>( 2 );</div>
<div class="line"><a class="code" href="classDNS_1_1Cache.html#a788644ad9ee654b1d4ca3a9400e2f9e7">DNS::Cache::setRefreshPercent</a>( 70 );</div>
<div class="line"><a class="code" href="classDNS_1_1Cache.html#aeb2cb3ea28f9abd22d2aafc0f4104262">DNS::Cache::setRefreshInterval</a>( 60000 ); <span class="comment">// 60 seconds</span></div>
</div><!-- fragment --><p><b>Settings</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Method  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="classDNS_1_1Cache.html#ae2be30116662b904388fc43bf89e0ca0">DNS::Cache::setRefreshConcurrent()</a>  </td><td class="markdownTableBodyLeft">The maximum of refresh <a class="el" href="namespaceDNS.html">DNS</a> queries that will run concurrently. This is a throttling mechanism to ensure that not all refresh queries are submitted at exactly the same time.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="classDNS_1_1Cache.html#a788644ad9ee654b1d4ca3a9400e2f9e7">DNS::Cache::setRefreshPercent()</a>  </td><td class="markdownTableBodyLeft">This percentage indicates when a cached <a class="el" href="namespaceDNS.html">DNS</a> query will be eligible to be refreshed as a percentage of it's TTL (time to live).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="classDNS_1_1Cache.html#aeb2cb3ea28f9abd22d2aafc0f4104262">DNS::Cache::setRefreshInterval()</a>  </td><td class="markdownTableBodyLeft">This duration, in milliseconds, defines how often the system will check to see of there are any cached <a class="el" href="namespaceDNS.html">DNS</a> queries that are eligible to be refreshed.   </td></tr>
</table>
<p>Once these global <a class="el" href="classDNS_1_1Cache.html">DNS::Cache</a> settings have been configured, a <a class="el" href="namespaceDNS.html">DNS</a> cache is configured by adding the named servers to the <a class="el" href="namespaceDNS.html">DNS</a> cache.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define NS_OPS 1</span></div>
<div class="line">...</div>
<div class="line">DNS::Cache::getInstance(NS_OPS).addNamedServer(<span class="stringliteral">&quot;192.168.3.154&quot;</span>);</div>
<div class="line"><a class="code" href="classDNS_1_1Cache.html#a4f3e48e7596f08c4a7c845571ac25164">DNS::Cache::getInstance</a>(NS_OPS).<a class="code" href="classDNS_1_1Cache.html#a1c685ea7cbf5b8ab60e7223a21e087ae">addNamedServer</a>(<span class="stringliteral">&quot;192.168.3.155&quot;</span>);</div>
<div class="line"><a class="code" href="classDNS_1_1Cache.html#a4f3e48e7596f08c4a7c845571ac25164">DNS::Cache::getInstance</a>(NS_OPS).<a class="code" href="classDNS_1_1Cache.html#a1c685ea7cbf5b8ab60e7223a21e087ae">addNamedServer</a>(<span class="stringliteral">&quot;192.168.3.156&quot;</span>);</div>
<div class="line"><a class="code" href="classDNS_1_1Cache.html#a4f3e48e7596f08c4a7c845571ac25164">DNS::Cache::getInstance</a>(NS_OPS).<a class="code" href="classDNS_1_1Cache.html#a47de773c1f31fd2436af7b4503664e3c">applyNamedServers</a>();</div>
<div class="line">...</div>
</div><!-- fragment --><p>In this case, three <a class="el" href="namespaceDNS.html">DNS</a> servers have been defined to provide access to the same information. The underlying <a class="el" href="namespaceDNS.html">DNS</a> library, <a href="[https://c-ares.haxx.se/](https://c-ares.haxx.se/)">c-ares</a>, handles when a query is sent to a specific <a class="el" href="namespaceDNS.html">DNS</a> server.</p>
<p><a class="el" href="classDNS_1_1Cache.html">DNS::Cache</a> provides a feature that will periodically save the <a class="el" href="namespaceDNS.html">DNS</a> queries that are in the <a class="el" href="namespaceDNS.html">DNS</a> cache (only the query, not the result) to a file. This file can then be loaded at startup to "prime" the cache.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">DNS::Cache::getInstance(NS_OPS).initSaveQueries(<span class="stringliteral">&quot;ops_queries.json&quot;</span>, 10000);</div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classDNS_1_1Cache.html#a4f3e48e7596f08c4a7c845571ac25164">DNS::Cache::getInstance</a>(NS_OPS).<a class="code" href="classDNS_1_1Cache.html#a3e0464482d38ff888e59abfd4efd1580">loadQueries</a>(<span class="stringliteral">&quot;ops_queries.json&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::exception&amp; e)</div>
<div class="line">{</div>
<div class="line">    std::cerr &lt;&lt; e.what() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="line">...</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-dns-queries"></a> </p>
<h3><a class="anchor" id="autotoc_md51"></a>
DNS Queries</h3>
<p><a class="el" href="namespaceDNS.html">DNS</a> queries can be submitted either synchronously or asynchronously via a <a class="el" href="namespaceDNS.html">DNS</a> cache object <a class="el" href="classDNS_1_1Cache.html#a651dac5179ee4e53dbe1ae4896dd41d3">DNS::Cache::getInstance()</a>. The query will first check to see if there is an unexpired result in the cache. If the query is in the cache and the results have not expired, the query results will be immediately returned to the caller. If not, the query is sent to a <a class="el" href="namespaceDNS.html">DNS</a> server to be processed. When the results are received, the cache is updated and the result is forwarded to the caller.</p>
<p><b>Synchronous <a class="el" href="namespaceDNS.html">DNS</a> Query</b> A synchronous <a class="el" href="namespaceDNS.html">DNS</a> query will wait for the query to be processed before returning. Depending on the configuration, this can take several seconds, so care should be taken. A <a class="el" href="namespaceDNS.html#aba0490320a5daa94b1852f3eac56882e">DNS::QueryPtr</a>, which is a shared pointer to a <a class="el" href="classDNS_1_1Query.html">DNS::Query</a> object, is returned. From this pointer, the results of the query can be accessed.</p>
<p><b>Example Synchronous <a class="el" href="namespaceDNS.html">DNS</a> Query</b> </p><div class="fragment"><div class="line">Bool cachehit = <a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>; <span class="comment">// indicates if the query response came from the cache</span></div>
<div class="line"><a class="code" href="namespaceDNS.html#aba0490320a5daa94b1852f3eac56882e">DNS::QueryPtr</a> q = <a class="code" href="classDNS_1_1Cache.html#a4f3e48e7596f08c4a7c845571ac25164">DNS::Cache::getInstance</a>(NS_OPS).<a class="code" href="classDNS_1_1Cache.html#ae81c17af7bc8660d5e3bc56b526fce8e">query</a>(ns_t_naptr,</div>
<div class="line">    <span class="stringliteral">&quot;tac-lb01.tac-hb01.tac.epc.mnc120.mcc310.3gppnetwork.org&quot;</span>, cachehit);</div>
<div class="line">q-&gt;dump(); <span class="comment">// prints the contents of the Query object, including the results</span></div>
</div><!-- fragment --><p><b>Asynchronous <a class="el" href="namespaceDNS.html">DNS</a> Query</b></p>
<p>An asynchronous <a class="el" href="namespaceDNS.html">DNS</a> query functions essentially the same, except that a callback function is called with the <a class="el" href="namespaceDNS.html#aba0490320a5daa94b1852f3eac56882e">DNS::QueryPtr</a> containing the results instead of returning the <a class="el" href="namespaceDNS.html#aba0490320a5daa94b1852f3eac56882e">DNS::QueryPtr</a>. The callback function is defined as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keyword">typedef</span> Void(*CachedDNSQueryCallback)(<a class="code" href="namespaceDNS.html#aba0490320a5daa94b1852f3eac56882e">QueryPtr</a> q, Bool cacheHit, <span class="keyword">const</span> Void *data);</div>
</div><!-- fragment --><p> If the query results will can be obtained from the cache, the callback function will be called from the same thread that submitted the query. Otherwise, the callback function will be called from a different thread.</p>
<p><b>Example Asynchronous <a class="el" href="namespaceDNS.html">DNS</a> Query</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> dnscb(<a class="code" href="namespaceDNS.html#aba0490320a5daa94b1852f3eac56882e">DNS::QueryPtr</a> q, <span class="keywordtype">bool</span> cacheHit, <span class="keyword">const</span> <span class="keywordtype">void</span> *data)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// data is an opaque pointer that was defined when the query issued</span></div>
<div class="line">    <span class="comment">// for example, data could point to an EThreadPrivate derived object</span></div>
<div class="line">    <span class="comment">//    that we can post an thread event message to</span></div>
<div class="line">    std::cout</div>
<div class="line">        &lt;&lt; (q-&gt;getError() ? <span class="stringliteral">&quot; FAILED&quot;</span>:<span class="stringliteral">&quot; SUCCEEDED&quot;</span>)</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot; cachehit=&quot;</span></div>
<div class="line">        &lt;&lt; (cacheHit?<span class="stringliteral">&quot;true&quot;</span>:<span class="stringliteral">&quot;false&quot;</span>)</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot; using callback&quot;</span></div>
<div class="line">        &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">    <a class="code" href="classDNS_1_1Cache.html#a4f3e48e7596f08c4a7c845571ac25164">DNS::Cache::getInstance</a>(NS_OPS).<a class="code" href="classDNS_1_1Cache.html#ae81c17af7bc8660d5e3bc56b526fce8e">query</a>(ns_t_naptr,</div>
<div class="line">        <span class="stringliteral">&quot;tac-lb01.tac-hb01.tac.epc.mnc120.mcc310.3gppnetwork.org&quot;</span>,dnscb,myThread);</div>
<div class="line">...</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-dns-epc-node-discovery"></a> </p>
<h3><a class="anchor" id="autotoc_md52"></a>
EPC Node Discovery</h3>
<p><a href="https://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=1702">3GPP TS 29.303</a> defines the procedures for EPC node discovery and selection. <em><b><a class="el" href="classEpcTools.html" title="The primary class used to initialize/uninitialize EpcTools.">EpcTools</a></b></em> supports the process as it relates to <a class="el" href="namespaceDNS.html">DNS</a> in the <a class="el" href="namespaceEPCDNS.html" title="The namespace for the TS 29.303 related DNS functions.">EPCDNS</a> namespace. This support includes the construction of node names in <a class="el" href="classEPCDNS_1_1Utility.html">EPCDNS::Utility</a>, various node selection wrappers and colocation determination.</p>
<p><b>Supported Node Names</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Node  </th><th class="markdownTableHeadLeft">Example   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Home Network  </td><td class="markdownTableBodyLeft"><code>mnc990.mcc311.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Home Network Gprs  </td><td class="markdownTableBodyLeft"><code>mnc990.mcc311.gprs</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">TAI FQDN  </td><td class="markdownTableBodyLeft"><code>tac-lb0A.tac-hb1B.tac.epc.mnc990.mcc311.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">MME FQDN  </td><td class="markdownTableBodyLeft"><code>mmec0A.mmegi1B.mme.epc.mnc990.mcc311.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">MME Pool FQDN  </td><td class="markdownTableBodyLeft"><code>mmegi1B.mme.epc.mnc990.mcc311.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">RAI FQDN  </td><td class="markdownTableBodyLeft"><code>rac01AB.lac23CD.rac.epc.mnc990.mcc311.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">RNC FQDN  </td><td class="markdownTableBodyLeft"><code>rnc01AB.rnc.epc.mnc990.mcc311.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">SGSN FQDN  </td><td class="markdownTableBodyLeft"><code>nri01AB.rac23CD.lac45EF.rac.epc.mnc990.mcc311.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">EPC Nodes Domain FQDN  </td><td class="markdownTableBodyLeft"><code>node.epc.mnc990.mcc311.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">EPC Node FQDN  </td><td class="markdownTableBodyLeft"><code>nodename.node.epc.mnc990.mcc311.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Non-Emergency ePDG OI FQDN  </td><td class="markdownTableBodyLeft"><code>epdg.epc.mnc990.mcc311.pub.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Non-Emergency ePDG TAI FQDN  </td><td class="markdownTableBodyLeft"><code>tac-lb0A.tac-hb1B.tac.epdg.epc.mnc990.mcc311.pub.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Non-Emergency ePDG LAC FQDN  </td><td class="markdownTableBodyLeft"><code>lac01AB.epdg.epc.mnc990.mcc311.pub.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Non-Emergency ePDG Visited Country FQDN  </td><td class="markdownTableBodyLeft"><code>epdg.epc.mcc311.visited-country.pub.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Emergency ePDG OI FQDN  </td><td class="markdownTableBodyLeft"><code>sos.epdg.epc.mnc990.mcc311.pub.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Emergency ePDG TAI FQDN  </td><td class="markdownTableBodyLeft"><code>tac-lb0A.tac-hb1B.tac.sos.epdg.epc.mnc990.mcc311.pub.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Emergency ePDG LAC FQDN  </td><td class="markdownTableBodyLeft"><code>lac01AB.sos.epdg.epc.mnc990.mcc311.pub.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Emergency ePDG Visited Country FQDN  </td><td class="markdownTableBodyLeft"><code>sos.epdg.epc.mcc311.visited-country.pub.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Global eNodeB ID  </td><td class="markdownTableBodyLeft"><code>enb.12AB.enb.epc.mnc990.mcc311.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Local Home Network FQDN  </td><td class="markdownTableBodyLeft"><code>lhn.mynetwork.lhn.epc.mcc311.visited-country.pub.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">EPC  </td><td class="markdownTableBodyLeft"><code>epc.mnc990.mcc311.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">APN FQDN  </td><td class="markdownTableBodyLeft"><code>apn1.apn.epc.mnc990.mcc311.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">APN  </td><td class="markdownTableBodyLeft"><code>apn1.apn.mnc990.mcc311.3gppnetwork.org</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Diameter FQDN  </td><td class="markdownTableBodyLeft"><code>diameter.epc.mnc990.mcc311.3gppnetwork.org</code>   </td></tr>
</table>
<p><b>Node Selection Wrappers</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Node Selector  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="classEPCDNS_1_1ENodeBUPFNodeSelector.html">EPCDNS::ENodeBUPFNodeSelector</a>  </td><td class="markdownTableBodyLeft">Used to identify a set of UPF's associated with an eNodeB. This is used by the NGIC-RTC SGW-C to identify SGW-U's that have been associated with a specific eNodeB.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="classEPCDNS_1_1EpcNodeSelector.html">EPCDNS::EpcNodeSelector</a>  </td><td class="markdownTableBodyLeft">Used for general EPC node selection based on the node name.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="classEPCDNS_1_1MMENodeSelector.html">EPCDNS::MMENodeSelector</a>  </td><td class="markdownTableBodyLeft">Used to identify the MME using the MME code using the MME group identifier.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="classEPCDNS_1_1PGWNodeSelector.html">EPCDNS::PGWNodeSelector</a>  </td><td class="markdownTableBodyLeft">Used by the SGW-C to identify a list of SGW-C's that can provide access to the requested APN.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="classEPCDNS_1_1PGWUPFNodeSelector.html">EPCDNS::PGWNodeSelector</a>  </td><td class="markdownTableBodyLeft">Used by the PGW-C to identify a list of PGW-U's by querying for the APN associated with the bearer.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="classEPCDNS_1_1SGWNodeSelector.html">EPCDNS::SGWNodeSelector</a>  </td><td class="markdownTableBodyLeft">Used by the MME to identify a list of SGW-C's querying for the TAI FQDN supporting an x_3gpp_sgw service or by issuing a Node query looking for a specific node that supports the x_3gpp_sgw service.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="classEPCDNS_1_1SGWUPFNodeSelector.html">EPCDNS::SGWUPFNodeSelector</a>  </td><td class="markdownTableBodyLeft">Used by the SGW-C to identify a list of SGW-U's by querying for the TAI FQDN supporting an x_3gpp_upf service or by issuing a Node query for the eNodeB that supports the x_3gpp_upf service.   </td></tr>
</table>
<p>See <a class="el" href="namespaceEPCDNS.html#a1a1ce3b28564c5bab7da910f7deadad1">EPCDNS::AppServiceEnum</a> for a list of supported services. See <a class="el" href="namespaceEPCDNS.html#ae03529998f35494078eb89a7e7e234d1">EPCDNS::AppProtocolEnum</a> for a list of supported protocols.</p>
<p><a class="anchor" id="feature-overview-dns-node-colocation"></a> </p>
<h3><a class="anchor" id="autotoc_md53"></a>
Node Colocation</h3>
<p>Node colocation is used to order two sets of nodes based on topological distance, closest to furthest. For example, you might want to find an SGW-U that is as close as possible to a particular eNodeB. Colocation is your answer. The process takes two <a class="el" href="classEPCDNS_1_1NodeSelectorResult.html">EPCDNS::NodeSelectorResult</a> objects which each contain a list of candidates and compares each element in the first <a class="el" href="classEPCDNS_1_1NodeSelectorResult.html">EPCDNS::NodeSelectorResult</a> object to each element in the seconds <a class="el" href="classEPCDNS_1_1NodeSelectorResult.html">EPCDNS::NodeSelectorResult</a> and calculates a score based on the <b>topon</b> node names. Once complete, the process returns a list of pairs of nodes comprising all combinations of both lists ordered by score, closest to furthest.</p>
<p>See <a href="https://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=1702">3GPP TS 29.303</a> for more information on <b>topon</b>, <b>topoff</b> and <b>colocation</b> (Appendix C-4).</p>
<p><b>Colocation Example</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#define NS_APP 2</span></div>
<div class="line">...</div>
<div class="line">EPCDNS::ENodeBUPFNodeSelector s1( <span class="stringliteral">&quot;0001&quot;</span>, <span class="stringliteral">&quot;120&quot;</span>, <span class="stringliteral">&quot;310&quot;</span> );</div>
<div class="line">s1.setNamedServerID(NS_APP);</div>
<div class="line">s1.addDesiredProtocol( <a class="code" href="namespaceEPCDNS.html#a9342407c49fe0b6a9612fed8e51f2d90ac0af35cebaee6964f6635f8b50f6bdfb">EPC::UPFAppProtocolEnum::upf_x_sxa</a> );</div>
<div class="line">s1.addDesiredNetworkCapability( <span class="stringliteral">&quot;lbo&quot;</span> );</div>
<div class="line">s1.process();</div>
<div class="line">s1.dump();</div>
<div class="line"> </div>
<div class="line">EPC::PGWUPFNodeSelector s2( <span class="stringliteral">&quot;apn1&quot;</span>, <span class="stringliteral">&quot;120&quot;</span>, <span class="stringliteral">&quot;310&quot;</span> );</div>
<div class="line">s2.setNamedServerID(NS_APP);</div>
<div class="line">s2.addDesiredProtocol( <a class="code" href="namespaceEPCDNS.html#a9342407c49fe0b6a9612fed8e51f2d90a17786ffff8236112de48747dba289ba7">EPC::UPFAppProtocolEnum::upf_x_sxb</a> );</div>
<div class="line">s2.addDesiredNetworkCapability( <span class="stringliteral">&quot;lbo&quot;</span> );</div>
<div class="line">s2.process();</div>
<div class="line">s2.dump();</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classEPCDNS_1_1ColocatedCandidateList.html">EPCDNS::ColocatedCandidateList</a> ccl( s1.getResults(), s2.getResults() );</div>
<div class="line">ccl.<a class="code" href="classEPCDNS_1_1ColocatedCandidateList.html#a13e5a7be8b6686f013c2dd5005cde27a">dump</a>();</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-dns-diameter-s-naptr"></a> </p>
<h3><a class="anchor" id="autotoc_md54"></a>
Diameter S-NAPTR</h3>
<p><a href="https://tools.ietf.org/html/rfc6408">RFC 6408</a> defines how <a class="el" href="namespaceDNS.html">DNS</a> can be used to locate hosts that support specific <a class="el" href="namespaceDNS.html">DNS</a> applications. The <a class="el" href="namespaceEPCDNS.html">EPCDNS</a> contains <a class="el" href="classEPCDNS_1_1DiameterSelector.html">DiameterSelector</a> which is used to locate diameter applications in <a class="el" href="namespaceDNS.html">DNS</a>. After setting the realm, application and protocol, <a class="el" href="classEPCDNS_1_1DiameterSelector.html#ac54f6f2ffb3b453492c8d26ada9afa17">DiameterSelector.process()</a> will return a list of <a class="el" href="classEPCDNS_1_1DiameterNaptr.html">DiameterNaptr</a> objects representing the nodes that support the requested application and protocol.</p>
<p>Refer to <a class="el" href="namespaceEPCDNS.html#ae38cedd2ac88e50be1a09c871ccfbd17">DiameterApplicationEnum</a> for a list of supported applications. <br  />
 Refer to <a class="el" href="namespaceEPCDNS.html#a28954380b48f08776a2a9444678bb713">DiameterProtocolEnum</a> for a list of supported protocols.</p>
<p><a class="anchor" id="feature-overview-management-interface-rest"></a> </p>
<h2><a class="anchor" id="autotoc_md55"></a>
Management Interface (REST)</h2>
<p><a class="el" href="classEManagementEndpoint.html">EManagementEndpoint</a> and <a class="el" href="classEManagementHandler.html">EManagementHandler</a> are classes that implement a REST server for the purpose of providing a management interface which can be used to retrieve run-time statistics or set run-time configuration values. The REST server is built using <a href="http://pistache.io/">pistache</a>. <a class="el" href="classEManagementEndpoint.html" title="Implemts the HTTP server endpoint.">EManagementEndpoint</a>](<a class="el" href="classEManagementEndpoint.html">EManagementEndpoint</a>) represents the REST server and classes derived from <a class="el" href="classEManagementHandler.html">EManagementHandler</a> process the individual REST requests.</p>
<p>To add a handler, perform the following steps:</p><ol type="1">
<li>Derive a class from <a class="el" href="classEManagementHandler.html">EManagementHandler</a></li>
<li>In the derived classes constructor, define the HTTP method and route associated with the handler.</li>
<li>Overload the <a class="el" href="classEManagementHandler.html#a4ffb3842d986ccfe8f076844872d93c7">process()</a> to process the request.</li>
</ol>
<p><b>NOTE</b>: The reference to the <a class="el" href="classELogger.html">ELogger</a> object passed in to the <a class="el" href="classEManagementHandler.html">EManagementHandler</a> constructor will be called each time the handler is accessed recording the time, user name and operation that was performed. The user name is obtained from a custom header that is required when submitting a request.</p>
<p><b>Example Initialization</b> </p><div class="fragment"><div class="line"><span class="comment">// intialize the CLI, listen on port 1234 for all interfaces</span></div>
<div class="line">m_cliep = <span class="keyword">new</span> <a class="code" href="classEManagementEndpoint.html">EManagementEndpoint</a>(1234);</div>
<div class="line"> </div>
<div class="line">m_statsget = <span class="keyword">new</span> CliStatsGet( <a class="code" href="classELogger.html#a94a47d71f929233a7100d573732e3cd9">ELogger::log</a>(LOG_AUDIT) );</div>
<div class="line">m_cliep-&gt;registerHandler( *m_statsget );</div>
<div class="line"> </div>
<div class="line">m_statsresetput = <span class="keyword">new</span> CliStatsResetPut( <a class="code" href="classELogger.html#a94a47d71f929233a7100d573732e3cd9">ELogger::log</a>(LOG_AUDIT) );</div>
<div class="line">m_cliep-&gt;registerHandler( *m_statsresetput );</div>
<div class="line"> </div>
<div class="line">m_cliep-&gt;start();</div>
</div><!-- fragment --><p><b>Example GET Handler</b> This handler returns the current statistics stored in <a class="el" href="classEStatistics.html">EStatistics</a>. </p><div class="fragment"><div class="line"><span class="keyword">class </span>CliStatsGet : <span class="keyword">public</span> <a class="code" href="classEManagementHandler.html">EManagementHandler</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    CliStatsGet(<a class="code" href="classELogger.html">ELogger</a> &amp;audit)</div>
<div class="line">        : <a class="code" href="classEManagementHandler.html">EManagementHandler</a>( <a class="code" href="classEManagementHandler.html">EManagementHandler</a>::HttpMethod::httpGet, <span class="stringliteral">&quot;/statistics&quot;</span>, audit )</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> Void <a class="code" href="classEManagementHandler.html#a4ffb3842d986ccfe8f076844872d93c7">process</a>(<span class="keyword">const</span> Pistache::Http::Request&amp; request, Pistache::Http::ResponseWriter &amp;response)</div>
<div class="line">    {</div>
<div class="line">        RAPIDJSON_NAMESPACE::Document doc;</div>
<div class="line">        RAPIDJSON_NAMESPACE::Document::AllocatorType &amp;allocator( doc.GetAllocator() );</div>
<div class="line"> </div>
<div class="line">        doc.SetObject();</div>
<div class="line">        doc.AddMember( <span class="stringliteral">&quot;reporttime&quot;</span>, RAPIDJSON_NAMESPACE::Value().SetString(<a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().Format(<span class="stringliteral">&quot;%Y-%m-%dT%H:%M:%S.%0&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>),allocator), allocator );</div>
<div class="line"> </div>
<div class="line">        RAPIDJSON_NAMESPACE::Value interfaces(RAPIDJSON_NAMESPACE::kArrayType);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;ifc : <a class="code" href="classEStatistics.html#a001deafe916c830bd1c01994af35f4c1">EStatistics::getInterfaces</a>())</div>
<div class="line">        {</div>
<div class="line">            RAPIDJSON_NAMESPACE::Value interface(RAPIDJSON_NAMESPACE::kObjectType);</div>
<div class="line"> </div>
<div class="line">            interface.AddMember( <span class="stringliteral">&quot;name&quot;</span>, RAPIDJSON_NAMESPACE::Value().SetString(ifc.second.getName(),allocator), allocator );</div>
<div class="line">            <span class="keywordflow">switch</span> (ifc.second.getProtocol())</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code" href="classEStatistics.html#af0c90a6321515dc102a560fea68e2201a35f16dc084a53860f5cb3962107d5378">EStatistics::ProtocolType::diameter</a>: { interface.AddMember (<span class="stringliteral">&quot;protocol&quot;</span>, RAPIDJSON_NAMESPACE::Value().SetString(<span class="stringliteral">&quot;diameter&quot;</span>), allocator); <span class="keywordflow">break</span>; }</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code" href="classEStatistics.html#af0c90a6321515dc102a560fea68e2201adbc0c5628e752a4d82ae813db26ddccd">EStatistics::ProtocolType::gtpv2c</a>: { interface.AddMember (<span class="stringliteral">&quot;protocol&quot;</span>, RAPIDJSON_NAMESPACE::Value().SetString(<span class="stringliteral">&quot;gtpv2c&quot;</span>), allocator); <span class="keywordflow">break</span>; }</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code" href="classEStatistics.html#af0c90a6321515dc102a560fea68e2201ad1a0426a844b462d4c0af2928bee64c2">EStatistics::ProtocolType::gtpv1u</a>: { interface.AddMember (<span class="stringliteral">&quot;protocol&quot;</span>, RAPIDJSON_NAMESPACE::Value().SetString(<span class="stringliteral">&quot;gtpv1u&quot;</span>), allocator); <span class="keywordflow">break</span>; }</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code" href="classEStatistics.html#af0c90a6321515dc102a560fea68e2201adb636e1622edd7e74d1c1ad3c203c67b">EStatistics::ProtocolType::pfcp</a>: { interface.AddMember (<span class="stringliteral">&quot;protocol&quot;</span>, RAPIDJSON_NAMESPACE::Value().SetString(<span class="stringliteral">&quot;pfcp&quot;</span>), allocator); <span class="keywordflow">break</span>; }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            RAPIDJSON_NAMESPACE::Value peers(RAPIDJSON_NAMESPACE::kArrayType);</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;p : ifc.second.getPeers() )</div>
<div class="line">            {</div>
<div class="line">                RAPIDJSON_NAMESPACE::Value peer(RAPIDJSON_NAMESPACE::kObjectType);</div>
<div class="line"> </div>
<div class="line">                RAPIDJSON_NAMESPACE::Value address(RAPIDJSON_NAMESPACE::kObjectType);</div>
<div class="line">                <span class="keywordflow">switch</span> (ifc.second.getProtocol())</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">case</span> <a class="code" href="classEStatistics.html#af0c90a6321515dc102a560fea68e2201a35f16dc084a53860f5cb3962107d5378">EStatistics::ProtocolType::diameter</a>: { address.AddMember (<span class="stringliteral">&quot;diameterid&quot;</span>, RAPIDJSON_NAMESPACE::Value().SetString(p.second.getName(),allocator), allocator); <span class="keywordflow">break</span>; }</div>
<div class="line">                    <span class="keywordflow">case</span> <a class="code" href="classEStatistics.html#af0c90a6321515dc102a560fea68e2201adbc0c5628e752a4d82ae813db26ddccd">EStatistics::ProtocolType::gtpv2c</a>: { address.AddMember (<span class="stringliteral">&quot;ipv4&quot;</span>, RAPIDJSON_NAMESPACE::Value().SetString(p.second.getName(),allocator), allocator); <span class="keywordflow">break</span>; }</div>
<div class="line">                    <span class="keywordflow">case</span> <a class="code" href="classEStatistics.html#af0c90a6321515dc102a560fea68e2201ad1a0426a844b462d4c0af2928bee64c2">EStatistics::ProtocolType::gtpv1u</a>: { address.AddMember (<span class="stringliteral">&quot;ipv4&quot;</span>, RAPIDJSON_NAMESPACE::Value().SetString(p.second.getName(),allocator), allocator); <span class="keywordflow">break</span>; }</div>
<div class="line">                    <span class="keywordflow">case</span> <a class="code" href="classEStatistics.html#af0c90a6321515dc102a560fea68e2201adb636e1622edd7e74d1c1ad3c203c67b">EStatistics::ProtocolType::pfcp</a>: { address.AddMember (<span class="stringliteral">&quot;ipv4&quot;</span>, RAPIDJSON_NAMESPACE::Value().SetString(p.second.getName(),allocator), allocator); <span class="keywordflow">break</span>; }</div>
<div class="line">                }</div>
<div class="line">                peer.AddMember( <span class="stringliteral">&quot;address&quot;</span>, address, allocator );</div>
<div class="line"> </div>
<div class="line">                peer.AddMember( <span class="stringliteral">&quot;lastactivity&quot;</span>, RAPIDJSON_NAMESPACE::Value().SetString(p.second.getLastActivity().Format(<span class="stringliteral">&quot;%Y-%m-%dT%H:%M:%S.%0&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>),allocator), allocator );</div>
<div class="line">                  </div>
<div class="line">                RAPIDJSON_NAMESPACE::Value messages(RAPIDJSON_NAMESPACE::kArrayType);</div>
<div class="line">                <span class="keywordflow">for</span> ( <span class="keyword">auto</span> &amp;m : p.second.getMessageStats() )</div>
<div class="line">                {</div>
<div class="line">                    Bool nonzero = <a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>;</div>
<div class="line"> </div>
<div class="line">                    RAPIDJSON_NAMESPACE::Value msgstats(RAPIDJSON_NAMESPACE::kObjectType);</div>
<div class="line"> </div>
<div class="line">                    msgstats.AddMember( <span class="stringliteral">&quot;type&quot;</span>, RAPIDJSON_NAMESPACE::Value().SetString(m.second.getName().c_str(),allocator), allocator);</div>
<div class="line"> </div>
<div class="line">                    <span class="keywordflow">if</span> (m.second.getRequestSentErrors()) { msgstats.AddMember(<span class="stringliteral">&quot;rqst_send_errors&quot;</span>, m.second.getRequestSentErrors(), allocator); nonzero = <a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>; }</div>
<div class="line">                    <span class="keywordflow">if</span> (m.second.getRequestReceivedErrors()) { msgstats.AddMember(<span class="stringliteral">&quot;rqst_rcvd_errors&quot;</span>, m.second.getRequestReceivedErrors(), allocator); nonzero = <a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>; }</div>
<div class="line">                    <span class="keywordflow">if</span> (m.second.getRequestSentOk()) { msgstats.AddMember(<span class="stringliteral">&quot;rqst_send_ok&quot;</span>, m.second.getRequestSentOk(), allocator); nonzero = <a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>; }</div>
<div class="line">                    <span class="keywordflow">if</span> (m.second.getRequestReceivedOk()) { msgstats.AddMember(<span class="stringliteral">&quot;rqst_rcvd_ok&quot;</span>, m.second.getRequestReceivedOk(), allocator); nonzero = <a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>; }</div>
<div class="line">                    <span class="keywordflow">if</span> (m.second.getResponseSentErrors()) { msgstats.AddMember(<span class="stringliteral">&quot;resp_send_errors&quot;</span>, m.second.getResponseSentErrors(), allocator); nonzero = <a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>; }</div>
<div class="line">                    <span class="keywordflow">if</span> (m.second.getResponseReceivedErrors()) { msgstats.AddMember(<span class="stringliteral">&quot;resp_rcvd_errors&quot;</span>, m.second.getResponseReceivedErrors(), allocator); nonzero = <a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>; }</div>
<div class="line">                    <span class="keywordflow">if</span> (m.second.getResponseSentOkAccepted()) { msgstats.AddMember(<span class="stringliteral">&quot;resp_send_ok_accept&quot;</span>, m.second.getResponseSentOkAccepted(), allocator); nonzero = <a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>; }</div>
<div class="line">                    <span class="keywordflow">if</span> (m.second.getResponseSentOkRejected()) { msgstats.AddMember(<span class="stringliteral">&quot;resp_send_ok_reject&quot;</span>, m.second.getResponseSentOkRejected(), allocator); nonzero = <a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>; }</div>
<div class="line">                    <span class="keywordflow">if</span> (m.second.getResponseReceivedOkAccepted()) { msgstats.AddMember(<span class="stringliteral">&quot;resp_rcvd_ok_accept&quot;</span>, m.second.getResponseReceivedOkAccepted(), allocator); nonzero = <a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>; }</div>
<div class="line">                    <span class="keywordflow">if</span> (m.second.getResponseReceivedOkRejected()) { msgstats.AddMember(<span class="stringliteral">&quot;resp_rcvd_ok_reject&quot;</span>, m.second.getResponseReceivedOkRejected(), allocator); nonzero = <a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>; }</div>
<div class="line"> </div>
<div class="line">                    <span class="keywordflow">if</span> (nonzero)</div>
<div class="line">                        messages.PushBack( msgstats, allocator );</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                peer.AddMember( <span class="stringliteral">&quot;messages&quot;</span>, messages, allocator );</div>
<div class="line">                peers.PushBack( peer, allocator );</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            interface.AddMember( <span class="stringliteral">&quot;peers&quot;</span>, peers, allocator );</div>
<div class="line">            interfaces.PushBack( interface, allocator );</div>
<div class="line">        }</div>
<div class="line">          </div>
<div class="line">        doc.AddMember( <span class="stringliteral">&quot;interfaces&quot;</span>, interfaces, allocator );</div>
<div class="line"> </div>
<div class="line">        RAPIDJSON_NAMESPACE::StringBuffer buf;</div>
<div class="line">        RAPIDJSON_NAMESPACE::Writer&lt;RAPIDJSON_NAMESPACE::StringBuffer&gt; writer( buf );</div>
<div class="line">        doc.Accept( writer );</div>
<div class="line"> </div>
<div class="line">        response.send( Pistache::Http::Code::Ok, buf.GetString() );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    CliStatsGet();</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>Example PUT Handler</b> This handler sets the current message counts to zero that are stored in <a class="el" href="classEStatistics.html">EStatistics</a>. </p><div class="fragment"><div class="line"><span class="keyword">class </span>CliStatsResetPut : <span class="keyword">public</span> <a class="code" href="classEManagementHandler.html">EManagementHandler</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    CliStatsResetPut(<a class="code" href="classELogger.html">ELogger</a> &amp;audit)</div>
<div class="line">        : <a class="code" href="classEManagementHandler.html">EManagementHandler</a>( <a class="code" href="classEManagementHandler.html">EManagementHandler</a>::HttpMethod::httpPut, <span class="stringliteral">&quot;/statistics&quot;</span>, audit )</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> Void <a class="code" href="classEManagementHandler.html#a4ffb3842d986ccfe8f076844872d93c7">process</a>(<span class="keyword">const</span> Pistache::Http::Request&amp; request, Pistache::Http::ResponseWriter &amp;response)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="classEStatistics.html#afea33d5e78dd724f073b66b8d0913abf">EStatistics::reset</a>();</div>
<div class="line">        response.send( Pistache::Http::Code::Ok );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    CliStatsResetPut();</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>Example Handler Calls</b> </p><div class="fragment"><div class="line">$ curl -i -H &quot;X-User-Name: brian&quot; -H &quot;Content-Type: application/json&quot; http://localhost:9081/statistics</div>
<div class="line">HTTP/1.1 200 OK</div>
<div class="line">Connection: Keep-Alive</div>
<div class="line">Content-Length: 398</div>
<div class="line"> </div>
<div class="line">{&quot;reporttime&quot;:&quot;2020-01-28T17:13:49.860&quot;,&quot;interfaces&quot;:[{&quot;name&quot;:&quot;SWm&quot;,&quot;protocol&quot;:&quot;diameter&quot;,&quot;peers&quot;:[{&quot;address&quot;:{&quot;diameterid&quot;:&quot;epcappclient.localdomain&quot;},&quot;lastactivity&quot;:&quot;2020-01-27T16:04:14.716&quot;,&quot;messages&quot;:[{&quot;type&quot;:&quot;Diameter-EAP-Request&quot;,&quot;rqst_rcvd_ok&quot;:3},{&quot;type&quot;:&quot;AA-Answer&quot;,&quot;resp_send_ok_accept&quot;:1},{&quot;type&quot;:&quot;Diameter-EAP-Answer&quot;,&quot;resp_send_ok_accept&quot;:3},{&quot;type&quot;:&quot;AA-Request&quot;,&quot;rqst_rcvd_ok&quot;:1}]}]}]}</div>
<div class="line"> </div>
<div class="line">$ curl -i -X PUT -H &quot;X-User-Name: brian&quot; http://localhost:9081/statistics</div>
<div class="line">HTTP/1.1 200 OK</div>
<div class="line">Connection: Keep-Alive</div>
<div class="line">Content-Length: 0</div>
<div class="line"> </div>
<div class="line">$ curl -i -H &quot;X-User-Name: brian&quot; -H &quot;Content-Type: application/json&quot; http://localhost:9081/statistics</div>
<div class="line">HTTP/1.1 200 OK</div>
<div class="line">Connection: Keep-Alive</div>
<div class="line">Content-Length: 211</div>
<div class="line"> </div>
<div class="line">{&quot;reporttime&quot;:&quot;2020-01-28T17:16:48.300&quot;,&quot;interfaces&quot;:[{&quot;name&quot;:&quot;SWm&quot;,&quot;protocol&quot;:&quot;diameter&quot;,&quot;peers&quot;:[{&quot;address&quot;:{&quot;diameterid&quot;:&quot;epcappclient.localdomain&quot;},&quot;lastactivity&quot;:&quot;2020-01-27T16:04:14.716&quot;,&quot;messages&quot;:[]}]}]}</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-freediameter"></a> </p>
<h2><a class="anchor" id="autotoc_md56"></a>
freeDiameter</h2>
<p><a class="anchor" id="feature-overview-statistics"></a> </p>
<h2><a class="anchor" id="autotoc_md57"></a>
Interface Statistics</h2>
<p><a class="anchor" id="feature-overview-timer-pool"></a> </p>
<h2><a class="anchor" id="autotoc_md58"></a>
Timer Pool</h2>
<p><a class="anchor" id="feature-overview-miscellaneous-classes"></a> </p>
<h2><a class="anchor" id="autotoc_md59"></a>
Miscellaneous Classes</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Class  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="classEString.html">EString</a>  </td><td class="markdownTableBodyLeft">Derived from std::string, <a class="el" href="classEString.html">EString</a> adds additional string functionality including <a class="el" href="classEString.html#a320dce9f0bdcbf80118db0d623e176e1">format()</a>, <a class="el" href="classEString.html#a9d6babf402e62294f1f012a0a77a6fc1">tolower()</a>, <a class="el" href="classEString.html#a2c07071cfda4e2ff12eadcc30148970e">toupper()</a>, <a class="el" href="classEString.html#a64da598a2073ebdbec47bd70d3f7e153">ltrim()</a>, <a class="el" href="classEString.html#aec62cbea1ed4f596926765ef91681af7">rtrim()</a>, <a class="el" href="classEString.html#ae4511c6559c58985cd3a2adab71f3971">trim()</a>, <a class="el" href="classEString.html#a2d3d96ab171697b6939d91c70ee868c6">replaceAll()</a> and <a class="el" href="classEString.html#a2c4c0920ed9afc84f25fddbce595a42d">replaceAllCopy()</a>.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="classEUtility.html">EUtility</a>  </td><td class="markdownTableBodyLeft">General functionality that did not warrant a separate class. Static methods include <a class="el" href="classEUtility.html#a944fdd4bde5dcf2d0adc570e0f3c1b52">indexOf</a>, <a class="el" href="classEUtility.html#a565fb5cc0eea3d8292ba7e5a1122c0cd">indexOfAny()</a>, <a class="el" href="classEUtility.html#a8df7cc94aed8b0280efa09fc7e17da50">lastIndexOfAny()</a>, <a class="el" href="classEUtility.html#a866fd3da386083d3b0a822cf674490e3">split()</a>, <a class="el" href="classEUtility.html#a06d09ed5c6f844c0244ce1d6fcc68e1b">replaceAll()</a>, <a class="el" href="classEUtility.html#a8d4c5289980107c5622b29078db7b54a">replaceAllCopy()</a>, <a class="el" href="classEUtility.html#a20e1f771586bfe809ef2fe6582fcbb05">string_format()</a>, <a class="el" href="classEUtility.html#a9a5a99531cd26237a7adb16dd95f4f49">copy_file()</a>, <a class="el" href="classEUtility.html#a3bf11be84572d26a3747446707fc075d">delete_file()</a>, <a class="el" href="classEUtility.html#a3f7d8c79a89f3694018a5f6f9bb7ced0">file_exists()</a>, <a class="el" href="classEUtility.html#a4edb2b40da4ccde3f06253b4294b21e2">currentTime()</a>.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="classETime.html">ETime</a>  </td><td class="markdownTableBodyLeft">Used for storing and manipulating the date and time.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="classETimer.html">ETimer</a>  </td><td class="markdownTableBodyLeft">A stopwatch like timer that can measure durations in milliseconds or microseconds.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="classEPath.html">EPath</a>  </td><td class="markdownTableBodyLeft">A class for manipulating file and directory names.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="classEDirectory.html">EDirectory</a>  </td><td class="markdownTableBodyLeft">A class for accessing files in a directory.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="classEError.html">EError</a>  </td><td class="markdownTableBodyLeft">An exception object that extends std::exception.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="classEHash.html">EHash</a>  </td><td class="markdownTableBodyLeft">Calculates a hash value for a string or byte array.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="classEBzip2.html">EBzip2</a>  </td><td class="markdownTableBodyLeft">Writes and reads bzip compressed files.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="classECircularBuffer.html">ECircularBuffer</a>  </td><td class="markdownTableBodyLeft">Implements a thread safe circular buffer over a byte array.   </td></tr>
</table>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="aclassEThreadEventTimer_html"><div class="ttname"><a href="classEThreadEventTimer.html">EThreadEventTimer</a></div><div class="ttdoc">Thread timer class.</div><div class="ttdef"><b>Definition:</b> etevent.h:852</div></div>
<div class="ttc" id="aclassEManagementEndpoint_html"><div class="ttname"><a href="classEManagementEndpoint.html">EManagementEndpoint</a></div><div class="ttdoc">Implemts the HTTP server endpoint.</div><div class="ttdef"><b>Definition:</b> emgmt.h:130</div></div>
<div class="ttc" id="aclassEThreadEvent_html_a3003651d73c57459305d073e0f1ad389"><div class="ttname"><a href="classEThreadEvent.html#a3003651d73c57459305d073e0f1ad389">EThreadEvent::onInit</a></div><div class="ttdeci">virtual Void onInit()</div><div class="ttdoc">Called in the context of the thread when the EM_INIT event is processed.</div><div class="ttdef"><b>Definition:</b> etevent.h:1182</div></div>
<div class="ttc" id="aclassEGetOpt_html_ae8a83370799c1a12d423360b34486aa5a4c5bbfa8ae59b10e28b648eaf3039265"><div class="ttname"><a href="classEGetOpt.html#ae8a83370799c1a12d423360b34486aa5a4c5bbfa8ae59b10e28b648eaf3039265">EGetOpt::dtString</a></div><div class="ttdoc">string</div><div class="ttdef"><b>Definition:</b> egetopt.h:51</div></div>
<div class="ttc" id="aclassEThreadEventMessageBase_html_a230c9b28843f770b7cbe41c573516603"><div class="ttname"><a href="classEThreadEventMessageBase.html#a230c9b28843f770b7cbe41c573516603">EThreadEventMessageBase::data</a></div><div class="ttdeci">T &amp; data()</div><div class="ttdoc">Retrieves the data portion of the message.</div><div class="ttdef"><b>Definition:</b> etevent.h:233</div></div>
<div class="ttc" id="aclassEThreadQueuePublic_html"><div class="ttname"><a href="classEThreadQueuePublic.html">EThreadQueuePublic</a></div><div class="ttdoc">Definition of a public event thread message queue.</div><div class="ttdef"><b>Definition:</b> etevent.h:566</div></div>
<div class="ttc" id="aclassESocket_1_1Thread_html"><div class="ttname"><a href="classESocket_1_1Thread.html">ESocket::Thread</a></div><div class="ttdoc">The socket thread base class. An event based thread class capable of surfacing socket events.</div><div class="ttdef"><b>Definition:</b> esocket.h:1438</div></div>
<div class="ttc" id="aclassELogger_html_a22fb57bad0e9b0ead993bf7dfb3d3968a1f0f01a3b5937718bea0102b7048dd26"><div class="ttname"><a href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a1f0f01a3b5937718bea0102b7048dd26">ELogger::eDebug</a></div><div class="ttdoc">Debug.</div><div class="ttdef"><b>Definition:</b> elogger.h:87</div></div>
<div class="ttc" id="aclassEStatistics_html_af0c90a6321515dc102a560fea68e2201adbc0c5628e752a4d82ae813db26ddccd"><div class="ttname"><a href="classEStatistics.html#af0c90a6321515dc102a560fea68e2201adbc0c5628e752a4d82ae813db26ddccd">EStatistics::ProtocolType::gtpv2c</a></div></div>
<div class="ttc" id="aclassETimer_html_a83ddc450e6e02c4528c967ac07f0c155"><div class="ttname"><a href="classETimer.html#a83ddc450e6e02c4528c967ac07f0c155">ETimer::MilliSeconds</a></div><div class="ttdeci">epctime_t MilliSeconds(Bool bRestart=False)</div><div class="ttdoc">Retrieves the current value of the timer in milliseconds.</div><div class="ttdef"><b>Definition:</b> etimer.cpp:81</div></div>
<div class="ttc" id="aclassEThreadBasic_html_a2af11d0367222ca518151c21f543a6ec"><div class="ttname"><a href="classEThreadBasic.html#a2af11d0367222ca518151c21f543a6ec">EThreadBasic::threadProc</a></div><div class="ttdeci">virtual Dword threadProc(pVoid arg)=0</div><div class="ttdoc">Function that will be called in a separate thread.</div></div>
<div class="ttc" id="aclassELogger_html_a22fb57bad0e9b0ead993bf7dfb3d3968a70c3ea4d2caebd12b06270bb858acb61"><div class="ttname"><a href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a70c3ea4d2caebd12b06270bb858acb61">ELogger::eStartup</a></div><div class="ttdoc">Startup.</div><div class="ttdef"><b>Definition:</b> elogger.h:91</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Talker_html_a2a2e9f2861837116aff0c3c96656afdb"><div class="ttname"><a href="classESocket_1_1TCP_1_1Talker.html#a2a2e9f2861837116aff0c3c96656afdb">ESocket::TCP::Talker::getRemotePort</a></div><div class="ttdeci">UShort getRemotePort() const</div><div class="ttdoc">Retrieves the port associated with the remote socket.</div><div class="ttdef"><b>Definition:</b> esocket.h:609</div></div>
<div class="ttc" id="aclassELogger_html_a3b04b024d3ba2c8ca119e4ff5cc2f6a7"><div class="ttname"><a href="classELogger.html#a3b04b024d3ba2c8ca119e4ff5cc2f6a7">ELogger::startup</a></div><div class="ttdeci">Void startup(cpStr format, const Args &amp;... args)</div><div class="ttdoc">Writes a startup message to this logger.</div><div class="ttdef"><b>Definition:</b> elogger.h:169</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Listener_html_abb5e0d65fddbc44cfcfdbc6d8404ca97"><div class="ttname"><a href="classESocket_1_1TCP_1_1Listener.html#abb5e0d65fddbc44cfcfdbc6d8404ca97">ESocket::TCP::Listener::~Listener</a></div><div class="ttdeci">virtual ~Listener()</div><div class="ttdoc">Class destructor.</div><div class="ttdef"><b>Definition:</b> esocket.h:963</div></div>
<div class="ttc" id="aclassDNS_1_1Cache_html_a47de773c1f31fd2436af7b4503664e3c"><div class="ttname"><a href="classDNS_1_1Cache.html#a47de773c1f31fd2436af7b4503664e3c">DNS::Cache::applyNamedServers</a></div><div class="ttdeci">Void applyNamedServers()</div><div class="ttdoc">Updates the named servers as a set in the underlying c-ares library.</div><div class="ttdef"><b>Definition:</b> dnscache.cpp:461</div></div>
<div class="ttc" id="aclassELogger_html_a7656e745ab38929f87ec9a50e355ab3d"><div class="ttname"><a href="classELogger.html#a7656e745ab38929f87ec9a50e355ab3d">ELogger::setLogLevel</a></div><div class="ttdeci">Void setLogLevel(LogLevel lvl)</div><div class="ttdoc">Assign a log level for this logger. Any log messages lower than the specified log level will not be w...</div><div class="ttdef"><b>Definition:</b> elogger.h:191</div></div>
<div class="ttc" id="aclassEEvent_html"><div class="ttname"><a href="classEEvent.html">EEvent</a></div><div class="ttdoc">An object that can be waited on to be set in another thread.</div><div class="ttdef"><b>Definition:</b> esynch.h:616</div></div>
<div class="ttc" id="aclassETime_html_a18dad5deae22bfe316cad3171daca59c"><div class="ttname"><a href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a></div><div class="ttdeci">static ETime Now()</div><div class="ttdoc">Retrieves the current time.</div><div class="ttdef"><b>Definition:</b> etime.cpp:1147</div></div>
<div class="ttc" id="aclassEThreadEvent_html_ad9dbc8444a26b5865c399f5a075daf2c"><div class="ttname"><a href="classEThreadEvent.html#ad9dbc8444a26b5865c399f5a075daf2c">EThreadEvent::initTimer</a></div><div class="ttdeci">Void initTimer(EThreadEventTimer &amp;t)</div><div class="ttdoc">Intializes an EThreadEvent::Timer object and associates with this thread.</div><div class="ttdef"><b>Definition:</b> etevent.h:1203</div></div>
<div class="ttc" id="aclassEThreadBasic_html_a94c06aeb1d4a549f367fda6d39c43a71"><div class="ttname"><a href="classEThreadBasic.html#a94c06aeb1d4a549f367fda6d39c43a71">EThreadBasic::sleep</a></div><div class="ttdeci">static Void sleep(Int milliseconds)</div><div class="ttdoc">Sleeps for the specified number of milliseconds.</div><div class="ttdef"><b>Definition:</b> etbasic.cpp:149</div></div>
<div class="ttc" id="anamespaceESocket_html"><div class="ttname"><a href="namespaceESocket.html">ESocket</a></div><div class="ttdoc">The namespace for all socket related classes.</div><div class="ttdef"><b>Definition:</b> esocket.h:42</div></div>
<div class="ttc" id="aebase_8h_html_add3ca9eefe3b5b754426f51d3043e579"><div class="ttname"><a href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></div><div class="ttdeci">#define True</div><div class="ttdoc">True.</div><div class="ttdef"><b>Definition:</b> ebase.h:25</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Listener_html"><div class="ttname"><a href="classESocket_1_1TCP_1_1Listener.html">ESocket::TCP::Listener</a></div><div class="ttdoc">Listens for incoming TCP/IP connections.</div><div class="ttdef"><b>Definition:</b> esocket.h:919</div></div>
<div class="ttc" id="aclassEThreadMessage_html"><div class="ttname"><a href="classEThreadMessage.html">EThreadMessage</a></div><div class="ttdoc">An event message that is to be sent to a thread.</div><div class="ttdef"><b>Definition:</b> etevent.h:266</div></div>
<div class="ttc" id="aclassDNS_1_1Cache_html_a4f3e48e7596f08c4a7c845571ac25164"><div class="ttname"><a href="classDNS_1_1Cache.html#a4f3e48e7596f08c4a7c845571ac25164">DNS::Cache::getInstance</a></div><div class="ttdeci">static Cache &amp; getInstance()</div><div class="ttdoc">Retrieves/creates the default Cache instance.</div><div class="ttdef"><b>Definition:</b> dnscache.h:203</div></div>
<div class="ttc" id="aclassEThreadEventTimer_html_a4b28f46b10c8164212e2713976f196b1"><div class="ttname"><a href="classEThreadEventTimer.html#a4b28f46b10c8164212e2713976f196b1">EThreadEventTimer::getId</a></div><div class="ttdeci">Long getId()</div><div class="ttdoc">Returns the unique timer id.</div><div class="ttdef"><b>Definition:</b> etevent.h:976</div></div>
<div class="ttc" id="aclassEGetOpt_html_ae38885648ab68337f86a54a29384f87a"><div class="ttname"><a href="classEGetOpt.html#ae38885648ab68337f86a54a29384f87a">EGetOpt::getCmdLine</a></div><div class="ttdeci">Long getCmdLine(cpStr path, Long def) const</div><div class="ttdoc">Returns the value of the specified command line argument as a 32-bit integer.</div><div class="ttdef"><b>Definition:</b> egetopt.cpp:302</div></div>
<div class="ttc" id="aclassEThreadEventMessageDataBase_html_aab7b01e9913284bd9af3d8d510ef892d"><div class="ttname"><a href="classEThreadEventMessageDataBase.html#aab7b01e9913284bd9af3d8d510ef892d">EThreadEventMessageDataBase::setVoidPtr</a></div><div class="ttdeci">virtual Void setVoidPtr(pVoid p)=0</div><div class="ttdoc">Sets the void pointer.</div></div>
<div class="ttc" id="aetevent_8h_html_a1fbc3aa077e4e82c9f1fa82d32653273"><div class="ttname"><a href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a></div><div class="ttdeci">#define ON_MESSAGE(id, memberFxn)</div><div class="ttdoc">Defines an invidual event handler.</div><div class="ttdef"><b>Definition:</b> etevent.h:817</div></div>
<div class="ttc" id="aclassEThreadEvent_html_adbdfea9c7c873363a05241dd166fa65b"><div class="ttname"><a href="classEThreadEvent.html#adbdfea9c7c873363a05241dd166fa65b">EThreadEvent::sendMessage</a></div><div class="ttdeci">Bool sendMessage(UInt message, Bool wait=True)</div><div class="ttdoc">Sends event message to this thread.</div><div class="ttdef"><b>Definition:</b> etevent.h:1082</div></div>
<div class="ttc" id="aclassDNS_1_1Cache_html_aeb2cb3ea28f9abd22d2aafc0f4104262"><div class="ttname"><a href="classDNS_1_1Cache.html#aeb2cb3ea28f9abd22d2aafc0f4104262">DNS::Cache::setRefreshInterval</a></div><div class="ttdeci">static long setRefreshInterval(long interval)</div><div class="ttdoc">Assigns the refresh interval.</div><div class="ttdef"><b>Definition:</b> dnscache.h:228</div></div>
<div class="ttc" id="aclassEMutexPublic_html_ab7ba904a8f25286d03118efaee635e84"><div class="ttname"><a href="classEMutexPublic.html#ab7ba904a8f25286d03118efaee635e84">EMutexPublic::attach</a></div><div class="ttdeci">Void attach(Int mutexid)</div><div class="ttdoc">Associates this public mutex object with the mutex ID located in shared memory.</div><div class="ttdef"><b>Definition:</b> esynch.cpp:425</div></div>
<div class="ttc" id="aclassEThreadEvent_html_acc26ee3ebe6b5a0e18477c39c01b3c3a"><div class="ttname"><a href="classEThreadEvent.html#acc26ee3ebe6b5a0e18477c39c01b3c3a">EThreadEvent::onTimer</a></div><div class="ttdeci">virtual Void onTimer(EThreadEventTimer *ptimer)</div><div class="ttdoc">Called in the context of the thread when th EM_TIMER event is processed.</div><div class="ttdef"><b>Definition:</b> etevent.h:1197</div></div>
<div class="ttc" id="aclassDNS_1_1Cache_html_a788644ad9ee654b1d4ca3a9400e2f9e7"><div class="ttname"><a href="classDNS_1_1Cache.html#a788644ad9ee654b1d4ca3a9400e2f9e7">DNS::Cache::setRefreshPercent</a></div><div class="ttdeci">static int setRefreshPercent(int percent)</div><div class="ttdoc">Assigns the refresh percentage value.</div><div class="ttdef"><b>Definition:</b> dnscache.h:220</div></div>
<div class="ttc" id="aclassELogger_html_a22fb57bad0e9b0ead993bf7dfb3d3968a17c9da6fdf1a7e126bf4a5ac16fe830e"><div class="ttname"><a href="classELogger.html#a22fb57bad0e9b0ead993bf7dfb3d3968a17c9da6fdf1a7e126bf4a5ac16fe830e">ELogger::eMinor</a></div><div class="ttdoc">Minor.</div><div class="ttdef"><b>Definition:</b> elogger.h:93</div></div>
<div class="ttc" id="aclassEMutexPrivate_html"><div class="ttname"><a href="classEMutexPrivate.html">EMutexPrivate</a></div><div class="ttdoc">A private mutex (the mutex data is allocated from either the heap or stack).</div><div class="ttdef"><b>Definition:</b> esynch.h:175</div></div>
<div class="ttc" id="aclassEThreadEvent_html"><div class="ttname"><a href="classEThreadEvent.html">EThreadEvent</a></div><div class="ttdoc">base class for EThreadPrivate and EThreadPublic</div><div class="ttdef"><b>Definition:</b> etevent.h:1040</div></div>
<div class="ttc" id="aclassELoggerSinkSet_html_a388a73618efe1cacb7e7481555040411"><div class="ttname"><a href="classELoggerSinkSet.html#a388a73618efe1cacb7e7481555040411">ELoggerSinkSet::addSink</a></div><div class="ttdeci">Void addSink(std::shared_ptr&lt; ELoggerSink &gt; &amp;sink)</div><div class="ttdoc">Adds a sink to the sink set.</div><div class="ttdef"><b>Definition:</b> elogger.h:474</div></div>
<div class="ttc" id="aclassEGetOpt_html_ad9e954c679c0c23a70dc67539876f9eea915d3f72218d564fb3c51a2d02784e6d"><div class="ttname"><a href="classEGetOpt.html#ad9e954c679c0c23a70dc67539876f9eea915d3f72218d564fb3c51a2d02784e6d">EGetOpt::no_argument</a></div><div class="ttdoc">no argument required</div><div class="ttdef"><b>Definition:</b> egetopt.h:38</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Talker_html_ab3fbfcfbd4fc5378966ad4362779006c"><div class="ttname"><a href="classESocket_1_1TCP_1_1Talker.html#ab3fbfcfbd4fc5378966ad4362779006c">ESocket::TCP::Talker::onClose</a></div><div class="ttdeci">virtual Void onClose()</div><div class="ttdoc">Called when the socket has been closed.</div><div class="ttdef"><b>Definition:</b> esocket.h:748</div></div>
<div class="ttc" id="aclassEThreadEventMessageBase_html"><div class="ttname"><a href="classEThreadEventMessageBase.html">EThreadEventMessageBase</a></div><div class="ttdoc">A template class that all event message classes should derive from.</div><div class="ttdef"><b>Definition:</b> etevent.h:206</div></div>
<div class="ttc" id="aclassEThreadEvent_html_a18fbce94b1fdc44d69cac2ca712fb90e"><div class="ttname"><a href="classEThreadEvent.html#a18fbce94b1fdc44d69cac2ca712fb90e">EThreadEvent::onQuit</a></div><div class="ttdeci">virtual Void onQuit()</div><div class="ttdoc">Called in the context of the thread when the EM_QUIT event is processed.</div><div class="ttdef"><b>Definition:</b> etevent.h:1186</div></div>
<div class="ttc" id="aclassEGetOpt_html_ad9e954c679c0c23a70dc67539876f9eea4e484f4b46faf0e8d2712a14087bb494"><div class="ttname"><a href="classEGetOpt.html#ad9e954c679c0c23a70dc67539876f9eea4e484f4b46faf0e8d2712a14087bb494">EGetOpt::required_argument</a></div><div class="ttdoc">an argument is required</div><div class="ttdef"><b>Definition:</b> egetopt.h:40</div></div>
<div class="ttc" id="astructEGetOpt_1_1Option_html"><div class="ttname"><a href="structEGetOpt_1_1Option.html">EGetOpt::Option</a></div><div class="ttdoc">Describes the defined command line arguments.</div><div class="ttdef"><b>Definition:</b> egetopt.h:67</div></div>
<div class="ttc" id="aetevent_8h_html_a0c8d25bf6492235c4f7f47ee387698ae"><div class="ttname"><a href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a></div><div class="ttdeci">#define BEGIN_MESSAGE_MAP(theClass, baseClass)</div><div class="ttdoc">Begins the message map declaration.</div><div class="ttdef"><b>Definition:</b> etevent.h:803</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Talker_html_a23c48944af233184985d92c0b155d5ae"><div class="ttname"><a href="classESocket_1_1TCP_1_1Talker.html#a23c48944af233184985d92c0b155d5ae">ESocket::TCP::Talker::Talker</a></div><div class="ttdeci">Talker(Thread&lt; TQueue, TMessage &gt; &amp;thread, Int bufsize=2097152)</div><div class="ttdoc">Class constructor.</div><div class="ttdef"><b>Definition:</b> esocket.h:548</div></div>
<div class="ttc" id="aclassESocket_1_1UDP_html_a7853433bb2daa353e88263ac62d9e04f"><div class="ttname"><a href="classESocket_1_1UDP.html#a7853433bb2daa353e88263ac62d9e04f">ESocket::UDP::onError</a></div><div class="ttdeci">virtual Void onError()</div><div class="ttdoc">Called when an error is detected on this socket.</div><div class="ttdef"><b>Definition:</b> esocket.h:1259</div></div>
<div class="ttc" id="aclassEGetOpt_html"><div class="ttname"><a href="classEGetOpt.html">EGetOpt</a></div><div class="ttdef"><b>Definition:</b> egetopt.h:31</div></div>
<div class="ttc" id="aclassEThreadEventTimer_html_ab95bdb5c96b1ebe5662785282584dbab"><div class="ttname"><a href="classEThreadEventTimer.html#ab95bdb5c96b1ebe5662785282584dbab">EThreadEventTimer::setInterval</a></div><div class="ttdeci">Void setInterval(Long interval)</div><div class="ttdoc">sets the timer interval</div><div class="ttdef"><b>Definition:</b> etevent.h:964</div></div>
<div class="ttc" id="aclassERWLock_html"><div class="ttname"><a href="classERWLock.html">ERWLock</a></div><div class="ttdoc">Encapsulates a read-write lock object.</div><div class="ttdef"><b>Definition:</b> esynch.h:507</div></div>
<div class="ttc" id="anamespaceESocket_html_a24cc0ce3fc2469d0913def48e8a7f4dd"><div class="ttname"><a href="namespaceESocket.html#a24cc0ce3fc2469d0913def48e8a7f4dd">ESocket::UdpPrivate</a></div><div class="ttdeci">UDP&lt; EThreadQueuePrivate&lt; EThreadMessage &gt;, EThreadMessage &gt; UdpPrivate</div><div class="ttdef"><b>Definition:</b> esocket.h:1879</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Talker_html"><div class="ttname"><a href="classESocket_1_1TCP_1_1Talker.html">ESocket::TCP::Talker</a></div><div class="ttdoc">A TCP socket class capabile of sending and receiving data.</div><div class="ttdef"><b>Definition:</b> esocket.h:540</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Talker_html_af4e3b0929084c49301d32a115dcde8bf"><div class="ttname"><a href="classESocket_1_1TCP_1_1Talker.html#af4e3b0929084c49301d32a115dcde8bf">ESocket::TCP::Talker::getLocalPort</a></div><div class="ttdeci">UShort getLocalPort() const</div><div class="ttdoc">Retrieves the port associated with the local socket.</div><div class="ttdef"><b>Definition:</b> esocket.h:574</div></div>
<div class="ttc" id="aclassEMutexPublic_html"><div class="ttname"><a href="classEMutexPublic.html">EMutexPublic</a></div><div class="ttdoc">A public mutex (the mutex data is located in shared memory).</div><div class="ttdef"><b>Definition:</b> esynch.h:223</div></div>
<div class="ttc" id="aclassEGetOpt_html_acf035f3e4bddbb4f4ef63c05e525af2f"><div class="ttname"><a href="classEGetOpt.html#acf035f3e4bddbb4f4ef63c05e525af2f">EGetOpt::loadCmdLine</a></div><div class="ttdeci">Void loadCmdLine(Int argc, pStr *argv, const EGetOpt::Option *options)</div><div class="ttdoc">Parses and loads the command line arguments.</div><div class="ttdef"><b>Definition:</b> egetopt.cpp:613</div></div>
<div class="ttc" id="aclassETimer_html"><div class="ttname"><a href="classETimer.html">ETimer</a></div><div class="ttdoc">Implements a stopwatch style timer.</div><div class="ttdef"><b>Definition:</b> etimer.h:26</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Listener_html_a2f9b721b8075770566ca000626d2f03f"><div class="ttname"><a href="classESocket_1_1TCP_1_1Listener.html#a2f9b721b8075770566ca000626d2f03f">ESocket::TCP::Listener::onClose</a></div><div class="ttdeci">virtual Void onClose()</div><div class="ttdoc">Called when this socket is closed.</div><div class="ttdef"><b>Definition:</b> esocket.h:1031</div></div>
<div class="ttc" id="aclassESharedMemory_html_affda2d92d4ba4506b196d7c266b777ad"><div class="ttname"><a href="classESharedMemory.html#affda2d92d4ba4506b196d7c266b777ad">ESharedMemory::getDataPtr</a></div><div class="ttdeci">pVoid getDataPtr()</div><div class="ttdoc">Retrieves a pointer to the first location of the shated memory.</div><div class="ttdef"><b>Definition:</b> eshmem.h:65</div></div>
<div class="ttc" id="aclassELogger_html"><div class="ttname"><a href="classELogger.html">ELogger</a></div><div class="ttdoc">Defines a logger.</div><div class="ttdef"><b>Definition:</b> elogger.h:78</div></div>
<div class="ttc" id="aclassEUtility_html_a3f7d8c79a89f3694018a5f6f9bb7ced0"><div class="ttname"><a href="classEUtility.html#a3f7d8c79a89f3694018a5f6f9bb7ced0">EUtility::file_exists</a></div><div class="ttdeci">static Bool file_exists(cpStr fn)</div><div class="ttdoc">Determines if the supplied file exists.</div><div class="ttdef"><b>Definition:</b> eutil.h:102</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Talker_html_aaf7cb01536df66dcf51bb34db1a4dd69"><div class="ttname"><a href="classESocket_1_1TCP_1_1Talker.html#aaf7cb01536df66dcf51bb34db1a4dd69">ESocket::TCP::Talker::write</a></div><div class="ttdeci">Void write(pUChar src, Int len)</div><div class="ttdoc">Writes data to the socket. This is a thread safe method.</div><div class="ttdef"><b>Definition:</b> esocket.h:704</div></div>
<div class="ttc" id="aclassESharedMemory_html_ad231d66f0e4d22240690008d6131cff7"><div class="ttname"><a href="classESharedMemory.html#ad231d66f0e4d22240690008d6131cff7">ESharedMemory::init</a></div><div class="ttdeci">Void init(cpStr file, Int id, Int size)</div><div class="ttdoc">Initializes this shared memory object. This method is called by the parameterized constructor.</div><div class="ttdef"><b>Definition:</b> eshmem.cpp:109</div></div>
<div class="ttc" id="aclassEMutexPublic_html_ab18eafe10a216cffb94fe4dd68bac0da"><div class="ttname"><a href="classEMutexPublic.html#ab18eafe10a216cffb94fe4dd68bac0da">EMutexPublic::mutexId</a></div><div class="ttdeci">Int mutexId()</div><div class="ttdoc">Retrieves the mutex ID associated with this public mutex.</div><div class="ttdef"><b>Definition:</b> esynch.h:253</div></div>
<div class="ttc" id="aclassEEvent_html_a2b3c1661daa5cd157f49b8cc2ea02bea"><div class="ttname"><a href="classEEvent.html#a2b3c1661daa5cd157f49b8cc2ea02bea">EEvent::wait</a></div><div class="ttdeci">Bool wait(int ms=-1)</div><div class="ttdoc">Waits for the event to be set.</div><div class="ttdef"><b>Definition:</b> esynch.cpp:684</div></div>
<div class="ttc" id="aebase_8h_html_a306ebd41c0cd1303b1372c6153f0caf8"><div class="ttname"><a href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></div><div class="ttdeci">#define False</div><div class="ttdoc">False.</div><div class="ttdef"><b>Definition:</b> ebase.h:27</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Talker_html_ad4b68e850d7e48377060cf52759496af"><div class="ttname"><a href="classESocket_1_1TCP_1_1Talker.html#ad4b68e850d7e48377060cf52759496af">ESocket::TCP::Talker::read</a></div><div class="ttdeci">Int read(pUChar dest, Int len)</div><div class="ttdoc">Rtrieves the specified number of bytes from the receive buffer.</div><div class="ttdef"><b>Definition:</b> esocket.h:697</div></div>
<div class="ttc" id="aclassESocket_1_1Base_html_a9b99ddcf9c8db8c26b7cb5eab79cfb7c"><div class="ttname"><a href="classESocket_1_1Base.html#a9b99ddcf9c8db8c26b7cb5eab79cfb7c">ESocket::Base::getError</a></div><div class="ttdeci">Int getError()</div><div class="ttdoc">Retrieves the last error value.</div><div class="ttdef"><b>Definition:</b> esocket.h:368</div></div>
<div class="ttc" id="aclassEThreadEventTimer_html_a6c65cb3297ebc6b37d0aaf8b38445ece"><div class="ttname"><a href="classEThreadEventTimer.html#a6c65cb3297ebc6b37d0aaf8b38445ece">EThreadEventTimer::setOneShot</a></div><div class="ttdeci">Void setOneShot(Bool oneshot)</div><div class="ttdoc">sets the type of timer</div><div class="ttdef"><b>Definition:</b> etevent.h:969</div></div>
<div class="ttc" id="aclassELogger_html_a1c628d5920ebdcc9593ac1413be45a94"><div class="ttname"><a href="classELogger.html#a1c628d5920ebdcc9593ac1413be45a94">ELogger::createSinkSet</a></div><div class="ttdeci">static ELoggerSinkSet &amp; createSinkSet(Int sinkid)</div><div class="ttdoc">Manually creates a sink set.</div><div class="ttdef"><b>Definition:</b> elogger.cpp:291</div></div>
<div class="ttc" id="aclassESocket_1_1UDP_html_abb7c08416e17e054fdb1c2af9f18e54c"><div class="ttname"><a href="classESocket_1_1UDP.html#abb7c08416e17e054fdb1c2af9f18e54c">ESocket::UDP::write</a></div><div class="ttdeci">Void write(const Address &amp;to, pVoid src, Int len)</div><div class="ttdoc">Sends data to the specified recipient address.</div><div class="ttdef"><b>Definition:</b> esocket.h:1193</div></div>
<div class="ttc" id="aclassEStatistics_html_a001deafe916c830bd1c01994af35f4c1"><div class="ttname"><a href="classEStatistics.html#a001deafe916c830bd1c01994af35f4c1">EStatistics::getInterfaces</a></div><div class="ttdeci">static InterfaceMap &amp; getInterfaces()</div><div class="ttdoc">Retrieves the interface collection.</div><div class="ttdef"><b>Definition:</b> estats.h:520</div></div>
<div class="ttc" id="aclassEGetOpt_html_ae8a83370799c1a12d423360b34486aa5aaef316de10f5737160a30a8a02f8211c"><div class="ttname"><a href="classEGetOpt.html#ae8a83370799c1a12d423360b34486aa5aaef316de10f5737160a30a8a02f8211c">EGetOpt::dtBool</a></div><div class="ttdoc">boolean</div><div class="ttdef"><b>Definition:</b> egetopt.h:63</div></div>
<div class="ttc" id="aclassEGetOpt_html_a6158a901a426b724a2990a7f70d89c82"><div class="ttname"><a href="classEGetOpt.html#a6158a901a426b724a2990a7f70d89c82">EGetOpt::get</a></div><div class="ttdeci">Long get(cpStr path, Long def) const</div><div class="ttdoc">Returns the value of the specified configuration value as a 32-bit integer.</div><div class="ttdef"><b>Definition:</b> egetopt.cpp:455</div></div>
<div class="ttc" id="aclassERDLock_html"><div class="ttname"><a href="classERDLock.html">ERDLock</a></div><div class="ttdoc">Request a read lock for the specified read-write lock object.</div><div class="ttdef"><b>Definition:</b> esynch.h:535</div></div>
<div class="ttc" id="aclassEPCDNS_1_1ColocatedCandidateList_html_a13e5a7be8b6686f013c2dd5005cde27a"><div class="ttname"><a href="classEPCDNS_1_1ColocatedCandidateList.html#a13e5a7be8b6686f013c2dd5005cde27a">EPCDNS::ColocatedCandidateList::dump</a></div><div class="ttdeci">Void dump(const char *prefix=&quot;&quot;)</div><div class="ttdoc">Prints the contents of this object.</div><div class="ttdef"><b>Definition:</b> epcdns.h:1422</div></div>
<div class="ttc" id="aclassEGetOpt_html_a1545ad2f720b632d5768e77bb287cc0d"><div class="ttname"><a href="classEGetOpt.html#a1545ad2f720b632d5768e77bb287cc0d">EGetOpt::print</a></div><div class="ttdeci">Void print() const</div><div class="ttdoc">Prints the current loaded values (command line and file).</div><div class="ttdef"><b>Definition:</b> egetopt.cpp:297</div></div>
<div class="ttc" id="aclassESemaphorePrivate_html"><div class="ttname"><a href="classESemaphorePrivate.html">ESemaphorePrivate</a></div><div class="ttdoc">Represents a private semaphore, the semaphore data is allocated from either the stack or heap.</div><div class="ttdef"><b>Definition:</b> esynch.h:382</div></div>
<div class="ttc" id="aclassEPCDNS_1_1ColocatedCandidateList_html"><div class="ttname"><a href="classEPCDNS_1_1ColocatedCandidateList.html">EPCDNS::ColocatedCandidateList</a></div><div class="ttdoc">A list of colocated candidates.</div><div class="ttdef"><b>Definition:</b> epcdns.h:1410</div></div>
<div class="ttc" id="aclassETime_html_a7c794038cc4ca2f0c9cffbf9e5a2bbee"><div class="ttname"><a href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">ETime::Format</a></div><div class="ttdeci">Void Format(EString &amp;dest, cpStr fmt, Bool local)</div><div class="ttdoc">Formats the date/time value as specified by the format string.</div><div class="ttdef"><b>Definition:</b> etime.cpp:1157</div></div>
<div class="ttc" id="aclassELogger_html_a94a47d71f929233a7100d573732e3cd9"><div class="ttname"><a href="classELogger.html#a94a47d71f929233a7100d573732e3cd9">ELogger::log</a></div><div class="ttdeci">static ELogger &amp; log(Int logid)</div><div class="ttdoc">Retrieves the requested ELogger object.</div><div class="ttdef"><b>Definition:</b> elogger.h:135</div></div>
<div class="ttc" id="aclassDNS_1_1Cache_html_a1c685ea7cbf5b8ab60e7223a21e087ae"><div class="ttname"><a href="classDNS_1_1Cache.html#a1c685ea7cbf5b8ab60e7223a21e087ae">DNS::Cache::addNamedServer</a></div><div class="ttdeci">Void addNamedServer(const char *address, int udp_port=53, int tcp_port=53)</div><div class="ttdoc">Adds a named server to this DNS cache object.</div><div class="ttdef"><b>Definition:</b> dnscache.cpp:451</div></div>
<div class="ttc" id="aclassEManagementHandler_html_a4ffb3842d986ccfe8f076844872d93c7"><div class="ttname"><a href="classEManagementHandler.html#a4ffb3842d986ccfe8f076844872d93c7">EManagementHandler::process</a></div><div class="ttdeci">virtual Void process(const Pistache::Http::Request &amp;request, Pistache::Http::ResponseWriter &amp;response)=0</div><div class="ttdoc">Pure virtual method that will be called by handler() to perform the processing.</div></div>
<div class="ttc" id="aclassDNS_1_1Cache_html_ae81c17af7bc8660d5e3bc56b526fce8e"><div class="ttname"><a href="classDNS_1_1Cache.html#ae81c17af7bc8660d5e3bc56b526fce8e">DNS::Cache::query</a></div><div class="ttdeci">QueryPtr query(ns_type rtype, const std::string &amp;domain, Bool &amp;cacheHit, Bool ignorecache=false)</div><div class="ttdoc">Performs a DNS query synchronously.</div><div class="ttdef"><b>Definition:</b> dnscache.cpp:466</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Talker_html_ac5052fac32b4e46a1d0fec4afeb5fcb6"><div class="ttname"><a href="classESocket_1_1TCP_1_1Talker.html#ac5052fac32b4e46a1d0fec4afeb5fcb6">ESocket::TCP::Talker::~Talker</a></div><div class="ttdeci">virtual ~Talker()</div><div class="ttdoc">Class destrucor.</div><div class="ttdef"><b>Definition:</b> esocket.h:557</div></div>
<div class="ttc" id="aclassEStatistics_html_afea33d5e78dd724f073b66b8d0913abf"><div class="ttname"><a href="classEStatistics.html#afea33d5e78dd724f073b66b8d0913abf">EStatistics::reset</a></div><div class="ttdeci">static Void reset()</div><div class="ttdoc">Sets the message counters to zero for all interfaces, peers and messages.</div><div class="ttdef"><b>Definition:</b> estats.cpp:42</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Talker_html_af8b8e2fc6259ff340b5b274105ac9060"><div class="ttname"><a href="classESocket_1_1TCP_1_1Talker.html#af8b8e2fc6259ff340b5b274105ac9060">ESocket::TCP::Talker::bytesPending</a></div><div class="ttdeci">Int bytesPending()</div><div class="ttdoc">Retrieves the number of bytes in the receive buffer.</div><div class="ttdef"><b>Definition:</b> esocket.h:680</div></div>
<div class="ttc" id="aclassEThreadEventMessageDataBase_html"><div class="ttname"><a href="classEThreadEventMessageDataBase.html">EThreadEventMessageDataBase</a></div><div class="ttdoc">The base class that all event message data objects should be derived from.</div><div class="ttdef"><b>Definition:</b> etevent.h:56</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Talker_html_aa2ee361ebd7638ae4a2c2a3c1dc44f39"><div class="ttname"><a href="classESocket_1_1TCP_1_1Talker.html#aa2ee361ebd7638ae4a2c2a3c1dc44f39">ESocket::TCP::Talker::onReceive</a></div><div class="ttdeci">virtual Void onReceive()</div><div class="ttdoc">Called when data has been received.</div><div class="ttdef"><b>Definition:</b> esocket.h:740</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Talker_html_a5a562f0af552cc6d69db5e056c841733"><div class="ttname"><a href="classESocket_1_1TCP_1_1Talker.html#a5a562f0af552cc6d69db5e056c841733">ESocket::TCP::Talker::disconnect</a></div><div class="ttdeci">Void disconnect()</div><div class="ttdoc">Disconnects this socket.</div><div class="ttdef"><b>Definition:</b> esocket.h:733</div></div>
<div class="ttc" id="aclassESharedMemory_html"><div class="ttname"><a href="classESharedMemory.html">ESharedMemory</a></div><div class="ttdoc">The shared memory access class.</div><div class="ttdef"><b>Definition:</b> eshmem.h:43</div></div>
<div class="ttc" id="aclassEThreadEventMessageDataBase_html_a54bf958a39d811cd2d2dac47eb842d22"><div class="ttname"><a href="classEThreadEventMessageDataBase.html#a54bf958a39d811cd2d2dac47eb842d22">EThreadEventMessageDataBase::getVoidPtr</a></div><div class="ttdeci">virtual pVoid getVoidPtr()=0</div><div class="ttdoc">Retrieves the void pointer.</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Talker_html_aee324d8b118f582de5ce69cf4e2ec6a8"><div class="ttname"><a href="classESocket_1_1TCP_1_1Talker.html#aee324d8b118f582de5ce69cf4e2ec6a8">ESocket::TCP::Talker::getLocalAddress</a></div><div class="ttdeci">EString getLocalAddress() const</div><div class="ttdoc">Retrieves the IP address associated with the local socket.</div><div class="ttdef"><b>Definition:</b> esocket.h:568</div></div>
<div class="ttc" id="aclassEThreadEventTimer_html_afe96e27e5031ae396f1f66160fb9e0ad"><div class="ttname"><a href="classEThreadEventTimer.html#afe96e27e5031ae396f1f66160fb9e0ad">EThreadEventTimer::start</a></div><div class="ttdeci">Void start()</div><div class="ttdoc">Starts the timer.</div><div class="ttdef"><b>Definition:</b> etevent.h:932</div></div>
<div class="ttc" id="aclassELogger_html_a5a215d97bbcce4d538a49a096dc7ef68"><div class="ttname"><a href="classELogger.html#a5a215d97bbcce4d538a49a096dc7ef68">ELogger::createLog</a></div><div class="ttdeci">static ELogger &amp; createLog(Int logid, cpStr category, Int sinkid)</div><div class="ttdoc">Manually creates a logger.</div><div class="ttdef"><b>Definition:</b> elogger.cpp:275</div></div>
<div class="ttc" id="aclassEWRLock_html"><div class="ttname"><a href="classEWRLock.html">EWRLock</a></div><div class="ttdoc">Request a write lock for the specified read-write lock object.</div><div class="ttdef"><b>Definition:</b> esynch.h:574</div></div>
<div class="ttc" id="aclassEThreadBasic_html"><div class="ttname"><a href="classEThreadBasic.html">EThreadBasic</a></div><div class="ttdoc">An abstract class that represents contains the threadProc() that will be run in a separate thread.</div><div class="ttdef"><b>Definition:</b> etbasic.h:53</div></div>
<div class="ttc" id="aetevent_8h_html_ae52a1e808bcf6220acbef40e8351b8e7"><div class="ttname"><a href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a></div><div class="ttdeci">#define END_MESSAGE_MAP()</div><div class="ttdoc">Ends the message map declaration.</div><div class="ttdef"><b>Definition:</b> etevent.h:821</div></div>
<div class="ttc" id="aetevent_8h_html_a3e0395c0f948348673c39d06c8bd12bf"><div class="ttname"><a href="etevent_8h.html#a3e0395c0f948348673c39d06c8bd12bf">DECLARE_MESSAGE_MAP</a></div><div class="ttdeci">#define DECLARE_MESSAGE_MAP()</div><div class="ttdoc">Inserts message map declarations into the thread class.</div><div class="ttdef"><b>Definition:</b> etevent.h:793</div></div>
<div class="ttc" id="aclassDNS_1_1Cache_html_a3e0464482d38ff888e59abfd4efd1580"><div class="ttname"><a href="classDNS_1_1Cache.html#a3e0464482d38ff888e59abfd4efd1580">DNS::Cache::loadQueries</a></div><div class="ttdeci">Void loadQueries(const char *qfn)</div><div class="ttdoc">Executes the DNS queries at startup from the suppoied file.</div><div class="ttdef"><b>Definition:</b> dnscache.cpp:503</div></div>
<div class="ttc" id="aclassEStatistics_html_af0c90a6321515dc102a560fea68e2201ad1a0426a844b462d4c0af2928bee64c2"><div class="ttname"><a href="classEStatistics.html#af0c90a6321515dc102a560fea68e2201ad1a0426a844b462d4c0af2928bee64c2">EStatistics::ProtocolType::gtpv1u</a></div></div>
<div class="ttc" id="aclassEManagementHandler_html"><div class="ttname"><a href="classEManagementHandler.html">EManagementHandler</a></div><div class="ttdoc">Pure virtual base class for an administrative management interface handler.</div><div class="ttdef"><b>Definition:</b> emgmt.h:70</div></div>
<div class="ttc" id="aclassDNS_1_1Cache_html_ae2be30116662b904388fc43bf89e0ca0"><div class="ttname"><a href="classDNS_1_1Cache.html#ae2be30116662b904388fc43bf89e0ca0">DNS::Cache::setRefreshConcurrent</a></div><div class="ttdeci">static unsigned int setRefreshConcurrent(unsigned int concur)</div><div class="ttdoc">Sets the maximum number of conncurrent DNS queries that can be performed while refreshing the DNS cac...</div><div class="ttdef"><b>Definition:</b> dnscache.h:212</div></div>
<div class="ttc" id="aclassEString_html_a320dce9f0bdcbf80118db0d623e176e1"><div class="ttname"><a href="classEString.html#a320dce9f0bdcbf80118db0d623e176e1">EString::format</a></div><div class="ttdeci">EString &amp; format(cpChar pszFormat,...)</div><div class="ttdoc">Sets the value to the string using a &quot;printf&quot; style format string and arguments.</div><div class="ttdef"><b>Definition:</b> estring.cpp:38</div></div>
<div class="ttc" id="aclassESocket_1_1Base_html_ab9d8e6493e00ee44723d9e62a879052c"><div class="ttname"><a href="classESocket_1_1Base.html#ab9d8e6493e00ee44723d9e62a879052c">ESocket::Base::getThread</a></div><div class="ttdeci">Thread&lt; TQueue, TMessage &gt; &amp; getThread()</div><div class="ttdoc">Retrieves the socket thread that this socket is associated with.</div><div class="ttdef"><b>Definition:</b> esocket.h:333</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Listener_html_a1477b6dd6c8da334612db807d9c22f75"><div class="ttname"><a href="classESocket_1_1TCP_1_1Listener.html#a1477b6dd6c8da334612db807d9c22f75">ESocket::TCP::Listener::onError</a></div><div class="ttdeci">virtual Void onError()</div><div class="ttdoc">Called when an error is detected on this socket.</div><div class="ttdef"><b>Definition:</b> esocket.h:1037</div></div>
<div class="ttc" id="aclassEString_html"><div class="ttname"><a href="classEString.html">EString</a></div><div class="ttdoc">String class.</div><div class="ttdef"><b>Definition:</b> estring.h:30</div></div>
<div class="ttc" id="anamespaceEPCDNS_html_a9342407c49fe0b6a9612fed8e51f2d90ac0af35cebaee6964f6635f8b50f6bdfb"><div class="ttname"><a href="namespaceEPCDNS.html#a9342407c49fe0b6a9612fed8e51f2d90ac0af35cebaee6964f6635f8b50f6bdfb">EPCDNS::upf_x_sxa</a></div><div class="ttdoc">x-sxa</div><div class="ttdef"><b>Definition:</b> epcdns.h:302</div></div>
<div class="ttc" id="aclassEStatistics_html_af0c90a6321515dc102a560fea68e2201a35f16dc084a53860f5cb3962107d5378"><div class="ttname"><a href="classEStatistics.html#af0c90a6321515dc102a560fea68e2201a35f16dc084a53860f5cb3962107d5378">EStatistics::ProtocolType::diameter</a></div></div>
<div class="ttc" id="aclassEThreadEvent_html_ad9c48af1f8f68bc7631c547ff2f31757"><div class="ttname"><a href="classEThreadEvent.html#ad9c48af1f8f68bc7631c547ff2f31757">EThreadEvent::quit</a></div><div class="ttdeci">Void quit()</div><div class="ttdoc">Posts the quit message to this thread.</div><div class="ttdef"><b>Definition:</b> etevent.h:1149</div></div>
<div class="ttc" id="aclassEGetOpt_html_a2cdd38746dcacdf53d016a50289e24a6"><div class="ttname"><a href="classEGetOpt.html#a2cdd38746dcacdf53d016a50289e24a6">EGetOpt::loadFile</a></div><div class="ttdeci">Void loadFile(cpStr filename)</div><div class="ttdoc">Parses and loads configuration values from the specified JSON file.</div><div class="ttdef"><b>Definition:</b> egetopt.cpp:748</div></div>
<div class="ttc" id="anamespaceESocket_1_1TCP_html_af194efe40cc3fd2948342f083b8b42e2"><div class="ttname"><a href="namespaceESocket_1_1TCP.html#af194efe40cc3fd2948342f083b8b42e2">ESocket::TCP::ListenerPrivate</a></div><div class="ttdeci">Listener&lt; EThreadQueuePrivate&lt; EThreadMessage &gt;, EThreadMessage &gt; ListenerPrivate</div><div class="ttdef"><b>Definition:</b> esocket.h:1876</div></div>
<div class="ttc" id="aclassEGetOpt_html_ae8a83370799c1a12d423360b34486aa5a0b3b4dd30b6b0868a0a0bf720c60136f"><div class="ttname"><a href="classEGetOpt.html#ae8a83370799c1a12d423360b34486aa5a0b3b4dd30b6b0868a0a0bf720c60136f">EGetOpt::dtNone</a></div><div class="ttdoc">no argument</div><div class="ttdef"><b>Definition:</b> egetopt.h:49</div></div>
<div class="ttc" id="aclassEError_html"><div class="ttname"><a href="classEError.html">EError</a></div><div class="ttdoc">The base class for exceptions derived from std::exception.</div><div class="ttdef"><b>Definition:</b> eerror.h:92</div></div>
<div class="ttc" id="aclassEEvent_html_affcbd4245ade48e1973cfd785e2e9f93"><div class="ttname"><a href="classEEvent.html#affcbd4245ade48e1973cfd785e2e9f93">EEvent::set</a></div><div class="ttdeci">Void set()</div><div class="ttdoc">Sets the event.</div><div class="ttdef"><b>Definition:</b> esynch.cpp:671</div></div>
<div class="ttc" id="aclassESocket_1_1Base_html"><div class="ttname"><a href="classESocket_1_1Base.html">ESocket::Base</a></div><div class="ttdoc">The base socket class.</div><div class="ttdef"><b>Definition:</b> esocket.h:317</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Talker_html_a1f2208e942a66964cc5be4ca1e172aa6"><div class="ttname"><a href="classESocket_1_1TCP_1_1Talker.html#a1f2208e942a66964cc5be4ca1e172aa6">ESocket::TCP::Talker::onConnect</a></div><div class="ttdeci">virtual Void onConnect()</div><div class="ttdoc">Called when a connection has been established.</div><div class="ttdef"><b>Definition:</b> esocket.h:744</div></div>
<div class="ttc" id="aebase_8h_html_a2017da1a7bf300a2d47bae722cec5e70"><div class="ttname"><a href="ebase_8h.html#a2017da1a7bf300a2d47bae722cec5e70">epctime_t</a></div><div class="ttdeci">long long int epctime_t</div><div class="ttdoc">time typedef</div><div class="ttdef"><b>Definition:</b> ebase.h:34</div></div>
<div class="ttc" id="anamespaceDNS_html_aba0490320a5daa94b1852f3eac56882e"><div class="ttname"><a href="namespaceDNS.html#aba0490320a5daa94b1852f3eac56882e">DNS::QueryPtr</a></div><div class="ttdeci">std::shared_ptr&lt; Query &gt; QueryPtr</div><div class="ttdoc">A typedef to std::shared_ptr&lt;Query&gt;.</div><div class="ttdef"><b>Definition:</b> dnsquery.h:40</div></div>
<div class="ttc" id="aclassELogger_html_a16b8ce5b92cfcb542abe981e481e2b77"><div class="ttname"><a href="classELogger.html#a16b8ce5b92cfcb542abe981e481e2b77">ELogger::sinkSet</a></div><div class="ttdeci">static ELoggerSinkSet &amp; sinkSet(Int sinkid)</div><div class="ttdoc">Retrieves the requested sink set object.</div><div class="ttdef"><b>Definition:</b> elogger.h:147</div></div>
<div class="ttc" id="anamespaceESocket_1_1TCP_html_a6ba05fd575a2c8260b8a447ca63cb2d5"><div class="ttname"><a href="namespaceESocket_1_1TCP.html#a6ba05fd575a2c8260b8a447ca63cb2d5">ESocket::TCP::TalkerPrivate</a></div><div class="ttdeci">Talker&lt; EThreadQueuePrivate&lt; EThreadMessage &gt;, EThreadMessage &gt; TalkerPrivate</div><div class="ttdef"><b>Definition:</b> esocket.h:1874</div></div>
<div class="ttc" id="aclassEStatistics_html_af0c90a6321515dc102a560fea68e2201adb636e1622edd7e74d1c1ad3c203c67b"><div class="ttname"><a href="classEStatistics.html#af0c90a6321515dc102a560fea68e2201adb636e1622edd7e74d1c1ad3c203c67b">EStatistics::ProtocolType::pfcp</a></div></div>
<div class="ttc" id="aclassESocket_1_1Address_html"><div class="ttname"><a href="classESocket_1_1Address.html">ESocket::Address</a></div><div class="ttdoc">Encapsulates a sockaddr_storage structure that represents a socket address.</div><div class="ttdef"><b>Definition:</b> esocket.h:143</div></div>
<div class="ttc" id="aclassESocket_1_1UDP_html"><div class="ttname"><a href="classESocket_1_1UDP.html">ESocket::UDP</a></div><div class="ttdoc">A UDP socket class capabile of sending and receiving data.</div><div class="ttdef"><b>Definition:</b> esocket.h:1072</div></div>
<div class="ttc" id="anamespaceEPCDNS_html_a9342407c49fe0b6a9612fed8e51f2d90a17786ffff8236112de48747dba289ba7"><div class="ttname"><a href="namespaceEPCDNS.html#a9342407c49fe0b6a9612fed8e51f2d90a17786ffff8236112de48747dba289ba7">EPCDNS::upf_x_sxb</a></div><div class="ttdoc">x-sxb</div><div class="ttdef"><b>Definition:</b> epcdns.h:304</div></div>
<div class="ttc" id="aclassELoggerSink_html"><div class="ttname"><a href="classELoggerSink.html">ELoggerSink</a></div><div class="ttdoc">Represents a logger output sink.</div><div class="ttdef"><b>Definition:</b> elogger.h:239</div></div>
<div class="ttc" id="aclassEMutexLock_html"><div class="ttname"><a href="classEMutexLock.html">EMutexLock</a></div><div class="ttdoc">Acquires and holds a lock on the specified mutex.</div><div class="ttdef"><b>Definition:</b> esynch.h:133</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Listener_html_ae5e39611743cf6dfac413e6a8d4f67bf"><div class="ttname"><a href="classESocket_1_1TCP_1_1Listener.html#ae5e39611743cf6dfac413e6a8d4f67bf">ESocket::TCP::Listener::createSocket</a></div><div class="ttdeci">Talker&lt; TQueue, TMessage &gt; * createSocket()</div><div class="ttdoc">Called to create a talking socket when a incoming connection is received.</div><div class="ttdef"><b>Definition:</b> esocket.h:1026</div></div>
<div class="ttc" id="aclassELogger_html_a06d60680bbf6cf1b235545786effb1bb"><div class="ttname"><a href="classELogger.html#a06d60680bbf6cf1b235545786effb1bb">ELogger::minor</a></div><div class="ttdeci">Void minor(cpStr format, const Args &amp;... args)</div><div class="ttdoc">Writes a minor message to this logger.</div><div class="ttdef"><b>Definition:</b> elogger.h:174</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Talker_html_a798d06b0be2a1fd8992797534e51b665"><div class="ttname"><a href="classESocket_1_1TCP_1_1Talker.html#a798d06b0be2a1fd8992797534e51b665">ESocket::TCP::Talker::getRemoteAddress</a></div><div class="ttdeci">EString getRemoteAddress() const</div><div class="ttdoc">Retrieves the IP address associated with the remote socket.</div><div class="ttdef"><b>Definition:</b> esocket.h:603</div></div>
<div class="ttc" id="aetevent_8h_html_a1a7c05eed44a6827c9ffd40fdd92fd50a53dfe5089ae9e65887cb0215cb0098f5"><div class="ttname"><a href="etevent_8h.html#a1a7c05eed44a6827c9ffd40fdd92fd50a53dfe5089ae9e65887cb0215cb0098f5">EThreadQueueMode::WriteOnly</a></div><div class="ttdoc">Allows read only access.</div></div>
<div class="ttc" id="aclassESocket_1_1TCP_1_1Listener_html_ac459e99dbb89be054d34665ac77b7f78"><div class="ttname"><a href="classESocket_1_1TCP_1_1Listener.html#ac459e99dbb89be054d34665ac77b7f78">ESocket::TCP::Listener::Listener</a></div><div class="ttdeci">Listener(Thread&lt; TQueue, TMessage &gt; &amp;thread, Family family=Family::INET6)</div><div class="ttdoc">Class constructor.</div><div class="ttdef"><b>Definition:</b> esocket.h:927</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
